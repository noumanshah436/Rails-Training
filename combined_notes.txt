
========================================================================================================================================================================
Topics (rails training)
========================================================================================================================================================================

Day 1:
Blog app
bundler
Friends app
Remote form submission
Ruby gems (ruby environment)
Use different rails version
Ruby Version Managers


Day 2:
SASS
Coffeescript

Day 3:
Active Record
Active Model
Migrations
Validations
Model Callbacks ( like before and after save )
Faker
gem 'activerecord-import' gem for bulk insertions

Day 4:
Action controller:

Parameters
Session
Flash
Cookies
Controller Callbacks
AR associations
renderring in different formats


Day 5:
routing

namespace
scope
queries
present vs exists

pending:
queries
theory



Day 6:
ActionView:

Layouts
Helper methods
Action View Form Helpers
Remote form submission
Pagination
Queries
form tags
View Helpers


Day 7
AR queries
Custom transaction
STI associations, Self Associations
eager_loading/pre_loading, lazy loading
exists? Vs present?
Calculations
scope in models
Group
Joins
Join2
preload, includes, eager_load
count / size / length
case expression in rails sql

Day 8
Mailing
Devise  + Active storage

Day 9 :
Background jobs
sidekiq
services vs concerncs


Rough Project:
  Rake tasks
  Carrierwaves


Day 10: (see folder)
rails rest apis
faker
Action cable
active storage


Day 11: (see folder)
react CRUD
React CRUD frontend
webpacker
Rake tasks


========================================================================================================================================================================
Other Topics
========================================================================================================================================================================

active storage ( react-crud)
Cloudinary (react-crud)
debugging
environment variables  (figaro)
Credentials
Email Verification devise
Devise controllers
postgre sql
chnage databaser from sqlite to postgres
chnage databaser from postgres to sqlite
pundit
rspec tests
rubocop
active_model_serializers

end of project Notes

Others Miscellaneous: ************

9_Best_Practices.txt
naming conventions
rails basic commands
rails error solution

rails installations: gems
gems -- multiple rails version


gems discovered:

enums- devise user role

lines used

Caching in Rails

ActiveRecord::Store

A Comprehensive Comparison: Rails 6 vs Rails 7

Rails7

Procfile (specifies the commands needed to run application)


========================================================================================================================================================================
Blog Notes
========================================================================================================================================================================
$ rails new blog
$ rails generate controller Welcome index

1) resources :articles

2) rails generate controller Articles
  -> now create action new and its view( html file)

3) create form in new.html.erb

4) make create method to get post request

5) create article model (  Models in Rails use a singular name, and their corresponding database tables use a plural name. )
  rails generate model Article title:string text:text
  rails db:migrate

6) showing article ( show method )
7) Listing article ( index method )

8) adding links to pages

9) add validations
The reason why we added @article = Article.new in the ArticlesController is that otherwise @article would be nil in our view, and calling @article.errors.any? would throw an error.

10) Updating Articles
It is not necessary to pass all the attributes to update. For example, if @article.update(title: 'A new title') was called, Rails would only update the title attribute, leaving all other attributes untouched.

11) Using partials to clean up duplication in views

12) Deleting Articles

11)  Generate comment model
rails generate model Comment commenter:string body:text article:references       ( we can manually add foreign key but this is better)
rails db:migrate

12) Associating Models
   add has many line ina article.db

13) adding route for comments
14) complete comment section
15) partail form comment
16) delete  comment
17) security


**************************

Migrations are Ruby classes that are designed to make it simple to create and modify database tables. Rails uses rake commands to run migrations, and it's possible to undo a migration after it's been applied to your database.


A frequent practice is to place the standard CRUD actions in each controller in the following order: index, show, new, edit, create, update and destroy. You may use any order you choose,



https://github.com/noumanshah436/Rails_Blog

****************

$ rake routes -c articles    (  see all routes of article )

rails g  (  see all generators)

rails -T ( see all available rails commands)


To see where a bundled gem is installed:
bundle info [gemname]

****************


redirect_to article_path(@article)

will redirect to the show method ( http://localhost:3000/articles/2 )

******************

Other authentication methods are available for Rails applications. Two popular authentication add-ons for Rails are the Devise rails engine and the Authlogic gem, along with a number of others.






========================================================================================================================================================================
Asset Pipeline
========================================================================================================================================================================


https://www.youtube.com/watch?v=l0E-D53gEL0

asset pipeline is a system of managing our static assets
asset pipelne also handle the preprocessing

*****************

//= require_tree .
this will include all files in the current directory and sub_directory

//= require_directory .
only include the assets in the current directory ( not from the nested directory)

//= require_directory ./public
load only file present in the public directory

*****************


see assets directly on chrome
http://localhost:3000/assets/jquery.js

bundle info jquery-rails


rails c
Rails.application.config.assets.paths
y _
exit


http://localhost:3000/?debug_assets=1
and then view page source to see all the file incluede


*******************

if you have something like jquery plugin that is not maintained by you that will be in vaendor/javascript directory


*******************

rails s -e production

************************

https://guides.rubyonrails.org/v5.2/asset_pipeline.html#coding-links-to-assets



========================================================================================================================================================================
Friends app
========================================================================================================================================================================

I am applying all commands in friends folder

$ rails new friends

$ rails s   or  rails server

localhost:3000

127.0.0.1:3000

********************

To create a new controller, you will need to run the "controller" generator and tell it you want a controller called "home" with an action called "index", just like this:

$ rails g controller home index

home is the controller name
index is the action name ()

http://localhost:3000/home/index

********************
to see all routes
$ rails routes

********************

partial files

_header.html.erb

use _ before partial file name and include in file without _

********************

Scaffold:

for CRUD operations we use scaffold:
$ rails g scaffold friends first_name:string last_name:string email:string phone:string twitter:string
( this will create all the CRUD functoinality )

$ pushing the migrations into the database( craete schema file):
rails db:migrate


delete this file as it is adding it own css:
scaffolds.scss

http://localhost:3000/friends

we need to use _path after prefix to create a link to that route

***************************************************************

devise gem: ( friends app)

Devise is the cornerstone gem for Ruby on Rails authentication. With Devise, creating a User that can log in and out of your application is so simple because Devise takes care of all the controllers necessary for user creation ( users_controller ) and for user sessions ( users_sessions_controller ).

Go to https://rubygems.org/   and search for devise

copy gem to gemfile
Go to its doc at github https://github.com/heartcombo/devise

bundle install will install all the gems in the gemfile

rails generate devise:install

complete instructions

rails g devise:views

rails generate devise user    ( this is migration command )
rails db:migrate              ( migrate )

Add links to navbar and style each page with bootstrap

**********************
model is like database

views are web pages

controller is like views in django

ctrl +c to break server

use two terminals open

for every web page we need a route


************************************


https://guides.rubyonrails.org/v3.2/migrations.html

***********************

scaffold:

1) rails g scaffold list name

2) rails g scaffold task name list:references

rails db:migrate

****************************************************************************
Ruby gems (ruby environment)
****************************************************************************



dev@nouman:~$ gem which rubocop
/home/dev/.rvm/gems/ruby-3.1.2/gems/rubocop-1.57.1/lib/rubocop.rb
dev@nouman:~$
dev@nouman:~$ cd /home/dev/.rvm/gems/ruby-3.1.2/gems
dev@nouman:~/.rvm/gems/ruby-3.1.2/gems$ ls
ast-2.4.2                          parallel-1.23.0  rainbow-3.1.1        rubocop-1.57.1      ruby-lsp-0.11.2          sorbet-runtime-0.5.11072     yarp-0.12.0
language_server-protocol-3.17.0.3  parser-3.2.2.4   regexp_parser-2.8.2  rubocop-ast-1.29.0  ruby-progressbar-1.13.0  unicode-display_width-2.5.0
dev@nouman:~/.rvm/gems/ruby-3.1.2/gems$ ls -al


**************************

ruby -v
ruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [x86_64-linux]


gem list

*** LOCAL GEMS ***


what are the gems it will show?

When you run gem list, it should display the gems that are installed for the currently active Ruby version.



**************************

gem environment
RubyGems Environment:
  - RUBYGEMS VERSION: 3.3.7
  - RUBY VERSION: 3.1.2 (2022-04-12 patchlevel 20) [x86_64-linux]
  - INSTALLATION DIRECTORY: /home/dev/.rvm/gems/ruby-3.1.2
  - USER INSTALLATION DIRECTORY: /home/dev/.local/share/gem/ruby/3.1.0
  - RUBY EXECUTABLE: /home/dev/.rvm/rubies/ruby-3.1.2/bin/ruby
  - GIT EXECUTABLE: /usr/bin/git
  - EXECUTABLE DIRECTORY: /home/dev/.rvm/gems/ruby-3.1.2/bin
  - SPEC CACHE DIRECTORY: /home/dev/.local/share/gem/specs
  - SYSTEM CONFIGURATION DIRECTORY: /etc
  - RUBYGEMS PLATFORMS:
     - ruby
     - x86_64-linux
  - GEM PATHS:
     - /home/dev/.rvm/gems/ruby-3.1.2
     - /home/dev/.rvm/rubies/ruby-3.1.2/lib/ruby/gems/3.1.0
  - GEM CONFIGURATION:
     - :update_sources => true
     - :verbose => true
     - :backtrace => false
     - :bulk_threshold => 1000
  - REMOTE SOURCES:
     - https://rubygems.org/
  - SHELL PATH:
     - /home/dev/.rvm/gems/ruby-3.1.2/bin
     - /home/dev/.rvm/gems/ruby-3.1.2@global/bin
     - /home/dev/.rvm/rubies/ruby-3.1.2/bin
     - /home/dev/.nvm/versions/node/v18.18.1/bin
     - /usr/local/sbin
     - /usr/local/bin
     - /usr/sbin
     - /usr/bin
     - /sbin
     - /bin
     - /usr/games
     - /usr/local/games
     - /snap/bin
     - /home/dev/.rvm/bin

******************************************************************************
rvm and ruby commands:
******************************************************************************


1) Install Ruby Versions
To install a specific Ruby version, use the rvm install command. For example, to install Ruby 3.1.2:

rvm install 3.1.2


2) Set Default Ruby Version

rvm use 3.1.2 --default

3) Switch Between Ruby Versions

rvm use 2.7.0

4) You can list all installed Ruby versions with:

rvm list

5) To uninstall a specific Ruby version, you can use:

rvm remove 3.1.2

6)
which ruby

/home/dev/.rvm/rubies/ruby-3.1.2/bin/ruby

**************************

rvm install '2.7.0'
rvm use 2.7.0 --default

which ruby
/home/dev/.rvm/rubies/ruby-2.7.0/bin/ruby


************************************************************************

Ruby Version Managers

https://launchschool.com/books/core_ruby_tools/read/ruby_version_managers


Suppose, though, that you want to use a different version of Ruby with one of your projects?
It's not too hard to switch versions with the rvm use VERSION command, but it is error prone: you will sometimes forget to change versions, and may also forget to switch back to the default ruby when you finish.
Instead, you should automate the version changes

The easiest is to create a .ruby-version file in your project's root directory; the content of this file is just the version number of ruby that you want to use

$ rvm --ruby-version use 2.7.0
or
$ echo "2.7.0" > .ruby-version

This creates a .ruby-version file in the directory. Once set, you don't need to worry about setting the version for this project

For good measure, you should set your default version in your home directory:

$ cd ~
$ rvm --ruby-version default

This ensures that RVM uses the default Ruby when you aren't in the project directory.

********************

echo "2.7.0" > .ruby-version
echo "3.0.3" > .ruby-version
echo "3.2.2" > .ruby-version

************************************************************************


$ rvm list
=* ruby-2.7.0 [ x86_64 ]
   ruby-3.1.2 [ x86_64 ]

# => - current
# =* - current && default
#  * - default


**********************

$ ruby -v
ruby 2.7.0p0 (2019-12-25 revision 647ee6f091) [x86_64-linux]


*********************


Lists all the gems that are installed in your current Ruby environment (for example ruby 2.7.0)
It displays the gems installed globally in your system-wide Ruby environment.
This command shows all the gems installed on your system, regardless of the specific project you are working on.

gem list

*** LOCAL GEMS ***

actioncable (5.2.8.1)
actionmailer (5.2.8.1)
actionpack (5.2.8.1)
actionview (5.2.8.1)
activejob (5.2.8.1)
activemodel (5.2.8.1)
activerecord (5.2.8.1)
.....
.....

Note:

if we change our ruby version (rvm use 3.1.2) and run `gem list` it will show gems for that ruby 3.1.2 environment

********************************

Search gems in the current ruby environment:

syntax:
     gem list gem-name

It will list all installed gems whose name matches gem-name. This is useful for checking if a specific gem is installed and seeing its version

Examples:

1) To check the version of the Bundler gem:

gem list bundler

*** LOCAL GEMS ***

bundler (default: 2.4.21, 2.3.19)
bundler-unload (1.0.2)
rubygems-bundler (1.4.5)

2) gem list devise

*** LOCAL GEMS ***

devise (4.8.1)

3) gem list rails

*** LOCAL GEMS ***

coffee-rails (4.2.2)
rails (5.2.8.1)
rails-dom-testing (2.0.3)
rails-html-sanitizer (1.4.3)
sass-rails (5.1.0)
sprockets-rails (3.4.2)


********************************

gem install bundler:2.3.19

********************************

$ bundle -v
Bundler version 2.4.21

$ bundler -v
Bundler version 2.4.21

*****************

$ bundler info devise

Could not locate Gemfile or .bundle/ directory

$ bundle list (or bundler list)

Could not locate Gemfile or .bundle/ directory

****************




******************************************************************************************************
What are the other ruby commands to check environment
******************************************************************************************************

In a Ruby development environment, there are several commands and tools you can use to check various aspects of the environment. Here are some commonly used commands:

ruby -v:
 This command displays the version of Ruby that is currently installed on your system.

gem -v:
 It shows the version of RubyGems, the package manager for Ruby, that is installed.

gem list:
 As mentioned earlier, this command lists all the gems that are installed in your Ruby environment.

irb: Running this command launches the Interactive Ruby (IRB) interpreter, which provides an interactive environment for executing Ruby code. It's great for experimenting and testing small snippets of code.

rails -v:
 If you have Ruby on Rails installed, this command displays the version of Rails that is installed.

rake -T:
 When you're in a Rails project directory, this command lists all available Rake tasks. Rake is a build tool similar to Make, and it's used in Rails for various tasks like running migrations, testing, etc.

bundle -v (or bundler -v):
 If you're using Bundler to manage gem dependencies in your project, this command shows the version of Bundler that is installed.

which ruby:
On Unix-like systems (Linux, macOS), this command displays the path to the currently active Ruby interpreter.

which gem:
Similarly, this command displays the path to the currently active gem executable.


These are just a few of the common commands used in a Ruby development environment. The specific commands you'll use will depend on the tools you have installed and the type of Ruby development you're doing (e.g., pure Ruby, Ruby on Rails, etc.).

***************************************************


rails console or rails c:
When you're in a Rails project directory, running either of these commands opens up a Rails console, which is an interactive environment similar to IRB but loaded with the Rails environment.

rails dbconsole or rails db:
 This command opens a database console for your Rails project's configured database. For example, rails dbconsole might open a PostgreSQL or MySQL console depending on your configuration.

rails routes:
In a Rails project directory, this command displays a list of all defined routes in your application.




******************************************************************************************************
Bundler:
******************************************************************************************************

In a Ruby on Rails project, Bundler is commonly used to manage gem dependencies.

Bundler is a tool used in the Ruby programming language ecosystem to manage gem dependencies for Ruby projects. It's a package manager for Ruby gems.
Gems are packages or libraries written in Ruby that provide specific functionality and can be easily integrated into your Ruby projects.
Bundler helps ensure that your project has the necessary gems and their correct versions, making it easier to manage and share code with others.

************************

Is bundler is a gem?

Yes, Bundler itself is a Ruby gem. It's a gem used for managing other gems, which are Ruby libraries or packages.
When you install Bundler, it becomes part of your Ruby environment and is used to manage the dependencies (other gems) for your Ruby projects.

To install Bundler as a gem, you can use the following command:

gem install bundler

This command will download and install Bundler from the RubyGems repository, making it available for use in your Ruby projects.
Once installed, you can create and manage the Gemfile for your projects, and Bundler will handle the installation and management of the specified gems and their versions.

************************

If bundler is a gem then why it is not mentioned in my Gemfile?

It's not necessary to list Bundler itself in your Gemfile because Bundler is a tool for managing other gems, not a gem that your project directly depends on.

The purpose of the Gemfile is to specify the gems that your Ruby project or application depends on for its functionality. These are the libraries that your code will use to accomplish specific tasks, and Bundler ensures that the correct versions of these gems are available for your project.

***********************

Here's how Bundler works and why it's important:

Dependency Management: In a Ruby project, you often rely on various gems to add specific features or functionality. These gems, in turn, may have their own dependencies on other gems. Managing all these dependencies manually can become complex. Bundler automates this process by keeping track of the gems your project needs and their versions.

Gemfile: In your project's directory, you create a file called Gemfile. This file lists the gems your project depends on along with their desired versions. Bundler reads this file to determine which gems to install.

Gemfile.lock: After running Bundler to install gems, it generates a Gemfile.lock file. This file locks in the specific versions of gems that were installed, ensuring consistency across different environments and preventing accidental updates to gems.

Installation: When you run bundle install (or just bundle), Bundler reads the Gemfile and installs the specified gems and their dependencies. It checks the Gemfile.lock to ensure that the exact versions mentioned there are installed, ensuring consistent behavior across different environments.

Updating Gems: You can update your project's gems by modifying the Gemfile and then running bundle update. This updates gems to the latest versions allowed by the version constraints in your Gemfile.

Isolation: Bundler creates a separate environment (a directory structure called the "bundle") for each project, ensuring that gem dependencies don't interfere with each other. This helps avoid conflicts between projects that might rely on different gem versions.

Collaboration: When sharing your code with others, you can include the Gemfile and Gemfile.lock files. When someone else clones your project and runs bundle install, they'll get the exact same gem versions that you're using, reducing potential compatibility issues.

In summary, Bundler simplifies the process of managing gem dependencies in Ruby projects, ensuring that the right versions of gems are installed and maintained consistently. It's a crucial tool for keeping projects organized, maintaining version control, and facilitating collaboration among developers.

************************

Commands:

In a Ruby on Rails project, Bundler is commonly used to manage gem dependencies.
Here are some of the most commonly used commands related to Bundler in a Rails context:

bundle install: This command reads the Gemfile in your Rails project directory and installs the specified gems and their dependencies. It creates or updates the Gemfile.lock file to record the exact versions of gems installed.

bundle update: Running this command updates the gems in your project to their latest versions based on the version constraints specified in the Gemfile. It also updates the Gemfile.lock accordingly.

bundle exec: When running Ruby scripts or commands that are part of your project (e.g., running Rails console or server), it's a good practice to prepend them with bundle exec to ensure that the correct gem versions are used as specified in your Gemfile.

For example: bundle exec rails server

bundle show: This command shows the location of a specific gem within the Bundler-managed environment. You can use it to check the installation path of gems.

For example: bundle show devise

bundle list: Similar to bundle show, this command displays a list of all the gems in your project's Bundler-managed environment along with their paths.

bundle check: This command checks if the gems specified in your Gemfile.lock are installed and available. It's useful for verifying that your environment matches the expected gem versions.

bundle clean: If you want to remove unused gems and their versions from the Bundler-managed environment, you can use this command. It helps keep your environment clean.

bundle init: If you're starting a new Rails project or just want to create a new Gemfile, you can use this command. It initializes a basic Gemfile with some default comments.

bundle install --path vendor/bundle: This command installs gems in a local directory within your project (vendor/bundle) rather than the system-wide gem location. This can be useful for isolating gems per project.

These commands help you manage and maintain gem dependencies in your Rails projects using Bundler. Remember that Bundler is an essential tool to ensure consistent and reproducible gem environments across different development and deployment environments.


******************************************************************************************************
bundle list vs gem list:
******************************************************************************************************

bundle list and gem list are two commands used in Ruby development to list information about installed gems, but they serve slightly different purposes:

gem list:

Command: gem list
Purpose: This command lists all the gems that are installed in your entire Ruby environment, regardless of whether they are managed by Bundler or installed globally.
Scope: It shows all gems available to your Ruby interpreter, including those managed by Bundler and those installed system-wide.
Output: The output includes the gem names and their versions.
bundle list:

Command: bundle list
Purpose: This command lists the gems that are installed and managed by Bundler in the context of the current Rails project.
Scope: It focuses specifically on the gems listed in the Gemfile.lock file and the gems installed within the Bundler-managed environment of the current project.
Output: The output includes the gem names, their versions, and the paths where they are installed within the Bundler-managed environment.


In summary, the main difference lies in the scope and purpose of the commands:

gem list provides a list of all installed gems across your entire Ruby environment, whether they are managed by Bundler or installed globally.
bundle list specifically shows the gems installed within the context of the current Rails project using Bundler, based on the Gemfile.lock and the Bundler-managed environment.
Depending on what information you need, you can use either command. If you're working within a Rails project and want to see the gems managed by Bundler, bundle list is more appropriate. If you want to see all installed gems in your entire Ruby environment, including global ones, gem list is the command to use.




The gem list command in Ruby is used to list the gems installed within the current Ruby environment.
It doesn't specifically target a particular gem or category of gems like "system gems" or "builder gems."

Instead, it provides a list of all gems that are installed and available for use in the currently active Ruby environment.


$ bundle list
Could not locate Gemfile or .bundle/ directory

$ gem list

*** LOCAL GEMS ***

actioncable (5.2.8.1)
actionmailer (5.2.8.1)
actionpack (5.2.8.1)
actionview (5.2.8.1)
activejob (5.2.8.1)



**************************************************************************

1) we paste gem (gem 'rswag-api', '~> 1.0') in gemfile and run bundle install
2) we run `gem install rswag-api -v 1.0.0`

are they install this gem in the ruby environment and what's the difference?

Answer:

1) When you add a gem to your project's Gemfile and run bundle install, you are specifying the gem as a dependency for your specific project.
The gem is installed in the context of your project's gem environment. It is isolated to your project and does not affect other Ruby projects or your system-wide Ruby environment.



2) When you run `gem install gemname -v version`, you are installing the gem system-wide on your Ruby environment.
This means the gem will be available for use in any Ruby project or script on your system that requires it. It is not project-specific.
It's useful when you want to install a gem globally on your system so that it's available for any Ruby project or script, regardless of the project's Gemfile.
However, it may not provide isolation between different projects, which can lead to gem version conflicts if multiple projects require different versions of the same gem.


In summary, the key difference is isolation and scope:

Using `bundle install` in a project's context isolates the gem to that project.
Running gem install installs the gem system-wide, making it available for any Ruby project.

The approach you choose depends on your specific use case and whether you want to manage gem dependencies at the project level or make a gem available globally for your entire Ruby environment.


**************************************************************************

you can use the gem env gemdir command to display the path to the directory where Ruby gems are stored on your system.

$ gem env gemdir
/home/dev/.rvm/gems/ruby-2.7.0

$ ruby -v
ruby 2.7.0p0 (2019-12-25 revision 647ee6f091) [x86_64-linux]




****************************************************************************
Use different rails version
****************************************************************************

$ ruby -v
ruby 2.7.0p0 (2019-12-25 revision 647ee6f091) [x86_64-linux]

$ gem install rails         (this will install the latest rails version)

$ rails -v
Rails 7.1.1

$ gem list | grep rails
rails (7.1.1, 5.2.8.1)

$ rails _5.2.8.1_ new myapp     (create rails app with older version )


$ cd Desktop/
$ rails new friends         (create rails app with latest version installed i.e 7.1.1 )

$ rails new myapp2

Resolving dependencies...
Bundle complete! 15 Gemfile dependencies, 83 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
         run  bundle lock --add-platform=x86_64-linux
Writing lockfile to /home/dev/Desktop/myapp2/Gemfile.lock
         run  bundle binstubs bundler
       rails  importmap:install
       apply  /home/dev/.rvm/gems/ruby-2.7.0/gems/importmap-rails-1.2.1/lib/install/install.rb
  Add Importmap include tags in application layout
      insert    app/views/layouts/application.html.erb
  Create application.js module as entrypoint
      create    app/javascript/application.js
  Use vendor/javascript for downloaded pins
      create    vendor/javascript
      create    vendor/javascript/.keep
  Ensure JavaScript files are in the Sprocket manifest
      append    app/assets/config/manifest.js
  Configure importmap paths in config/importmap.rb
      create    config/importmap.rb
  Copying binstub
      create    bin/importmap
         run  bundle install
Bundle complete! 15 Gemfile dependencies, 83 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
         run  bundle lock --add-platform=x86_64-linux
Writing lockfile to /home/dev/Desktop/myapp2/Gemfile.lock
       rails  turbo:install stimulus:install
       apply  /home/dev/.rvm/gems/ruby-2.7.0/gems/turbo-rails-1.5.0/lib/install/turbo_with_importmap.rb
  Import Turbo
      append    app/javascript/application.js
  Pin Turbo
      append    config/importmap.rb
         run  bundle install
Bundle complete! 15 Gemfile dependencies, 83 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
         run  bundle lock --add-platform=x86_64-linux
Writing lockfile to /home/dev/Desktop/myapp2/Gemfile.lock
Run turbo:install:redis to switch on Redis and use it in development for turbo streams
       apply  /home/dev/.rvm/gems/ruby-2.7.0/gems/stimulus-rails-1.3.0/lib/install/stimulus_with_importmap.rb
  Create controllers directory
      create    app/javascript/controllers
      create    app/javascript/controllers/index.js
      create    app/javascript/controllers/application.js
      create    app/javascript/controllers/hello_controller.js
  Import Stimulus controllers
      append    app/javascript/application.js
  Pin Stimulus
  Appending: pin "@hotwired/stimulus", to: "stimulus.min.js", preload: true"
      append    config/importmap.rb
  Appending: pin "@hotwired/stimulus-loading", to: "stimulus-loading.js", preload: true
      append    config/importmap.rb
  Pin all controllers
  Appending: pin_all_from "app/javascript/controllers", under: "controllers"
      append    config/importmap.rb
         run  bundle install
Bundle complete! 15 Gemfile dependencies, 83 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
         run  bundle lock --add-platform=x86_64-linux
Writing lockfile to /home/dev/Desktop/myapp2/Gemfile.lock

***************************

rails option:

rails new my-project -d=postgresql -c=tailwind

see all option by just type [rails new]

========================================================================================================================================================================
Day 2
coffeescript   SAAS
========================================================================================================================================================================
http://railscasts.com/episodes/267-coffeescript-basics?autoplay=true

1) rails new CoffeeScriptPractice

2) rails g controller home index


3) rails generate scaffold orders credit_card_number:string credit_card_expires_on:date
   rails db:migrate

5)

Put this in your app/assets/javascripts/application.js

//= require jquery
//= require jquery_ujs
and install this gem file:

gem 'jquery-rails'
bundle install


*****************************

javascript to coffeescript

1) use consistent tabs instead of curly braces
2) remove var for variables ( not needed)
3) remove return keyword ( automatically return like in ruby)
4) remove semicolon at the end of line

5) if function call have arguments , do not use parenthesis otherwise use ()
6) remove function keyword and use -> after arguments

7) replace "this." with an @ symbol
8) do not use () with if statement
9) replace ternary operator with if-then-else

*****************************

For jquery

1) remove () and {}

2) replace function() with ->
3) replace "this." with an @ symbol
3) replace $ with an jQuery ( not required )


***************************

sass is just a css preprocessor

Sass (which stands for 'Syntactically awesome style sheets) is an extension of CSS that enables you to use things like variables, nested rules, inline imports and more. It also helps to keep things organised and allows you to create style sheets faster. Sass is compatible with all versions of CSS.


========================================================================================================================================================================
Day 3
Active Record     and     active model
========================================================================================================================================================================

https://edgeguides.rubyonrails.org/active_model_basics.html

ActiveModel:  Active Model is a library containing various modules used in developing classes that need some features present on Active Record.  So ActiveModel includes things like validations.

1) When including ActiveModel::API you get some features like:

model name introspection
conversions
translations
validations
initialize object

2) The ActiveModel::AttributeMethods module can add custom prefixes and suffixes on methods of a class. It is used by defining the prefixes and suffixes and which methods on the object will use them.

3) ActiveModel::Callbacks gives Active Record style callbacks. This provides an ability to define callbacks which run at appropriate times. After defining callbacks, you can wrap them with before, after, and around custom methods.

4) An object becomes dirty when it has gone through one or more changes to its attributes and has not been saved. ActiveModel::Dirty gives the ability to check whether an object has been changed or not. It also has attribute-based accessor methods.


5) The ActiveModel::Validations module adds the ability to validate objects like in Active Record.

6) ActiveModel::Model allows implementing models similar to ActiveRecord::Base

7) ActiveModel::Serialization provides basic serialization for your object. You need to declare an attributes Hash which contains the attributes you want to serialize. Attributes must be strings, not symbols.

8) ActiveModel::SecurePassword provides a way to securely store any password in an encrypted form. When you include this module, a has_secure_password class method is provided which defines a password accessor with certain validations on it.


**********************

ActiveRecord: This is the component that associates a class to the database. This will give the class functionality such as methods that make it easy to pull records from the database (An example is the find method).

ActiveResource: Similar to ActiveRecord. However, instead of being backed by a database, an ActiveResource object is backed by another application through a web service API. More information: http://ofps.oreilly.com/titles/9780596521424/activeresource_id59243.html


“ORM: An object that wraps a row in a database table or view, encapsulates
the database access, and adds domain logic on that data.”

**********************

Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database.

Active Record gives us several mechanisms, the most important being the ability to:

Represent models and their data.
Represent associations between these models.
Represent inheritance hierarchies through related models.
Validate models before they get persisted to the database.
Perform database operations in an object-oriented fashion

***************

Active Record supports the following database column types ( datatypes database):

:binary
:boolean
:date
:datetime
:decimal
:float
:integer
:primary_key
:string
:text
:time
:timestamp


***************

Rails will plularize your tablename

Model name will automatically get pluralize in database


Model naming convention

Model/Class	Table/Schema
Article	articles
LineItem	line_items
Deer		deers
Mouse		mice
Person		people


Suppose you have Model name Book , it will store in sqlite as books and
in model it will be class name as  Book

This will create a Book model, mapped to a books table at the database

Book.all
Book.new
@book.save
@book.update
@book.destroy

**********************
in_batches:

1) by default batch size 1000:
UserScore.in_batches.update_all(created_at: DateTime.parse("2022-11-08 11:18:30 UTC"))

2) custom batch size:
UserScore.in_batches(of: 100000) do |relation|
  relation.update_all(created_at: DateTime.parse("2022-11-08 11:18:30 UTC"))
end

**************************

convert UTC to diff timezones:

utc_datetime = DateTime.parse("2022-11-08 11:18:30 UTC")
riyadh_timezone = ActiveSupport::TimeZone["Riyadh"]
riyadh_datetime = utc_datetime.in_time_zone(riyadh_timezone)
UserScore.in_batches(of: 100000) { |relation| relation.update_all(created_at: riyadh_datetime) }

datetime_string = "2022-11-08 11:18:30 UTC"
utc_datetime = DateTime.parse(datetime_string)
pakistan_timezone = ActiveSupport::TimeZone["Islamabad"]
pakistan_datetime = utc_datetime.in_time_zone(pakistan_timezone)
pakistan_datetime_str = pakistan_datetime.strftime("%Y-%m-%d %H:%M:%S %Z")



**********************

ACtive record errors:

@content_component.errors.full_messages_for(:icon).join(", ")
@content_component.errors.full_messages.join(", ")


*****************************
Activerecord lifecyle methods
*****************************

https://stackoverflow.com/questions/20720901/how-to-use-new-record-changed-and-persisted-methods-in-rails-in-this-example

 I will try explain the Activerecord lifecyle methods.

new_record? ****
car = Car.new # => initialize a new Car object
car.new_record? # => true


persisted? ****
car.save
car.persisted? # => true

changed? ****
car.model = 'New release model S'
car.changed? # => true

destroyed?  ****
car.destroy
car.destroyed? # => true



========================================================================================================================================================================
Active Record callbacks
========================================================================================================================================================================

https://guides.rubyonrails.org/v5.2/active_record_callbacks.html

Callbacks allow you to trigger logic before or after an alteration of an object's state.


Callbacks are methods that get called at certain moments of an object's life cycle.
With callbacks it is possible to write code that will run whenever an Active Record object is
created, saved, updated, deleted, validated, or loaded from the database.


***********************

  def greeting_message
    puts "before_create"
  end

  after_create do
      puts "after Create"
  end

  around_create do
    puts "around_create"
  end

  before_validation do
    puts "before valid"
  end

  after_validation do
    puts "afetr valid"
  end

end


# (0.1ms)  begin transaction
# before valid
# afetr valid
# before_create
# around_create
# after Create
# (0.1ms)  commit transaction

**************************

after_create :display_age

def display_age
  if self.age.present?
    puts "age=#{self.age}"
  else
      puts "age not present"
  end
end

**************************
 after_create :display_age

  def display_age
    if self.DOB.present?
      age= Date.today.year - self.DOB.year
      puts "====age=#{age}===="
    else
        puts "DOB not present"
    end
  end

 p = Person.create(name: "Nouman", age: 23, DOB:"1998-11-19")
 p = Person.create(name: "Nouman", age: 23, DOB: Date.today - 24.years)

**************************


========================================================================================================================================================================
Active Record CRUD
========================================================================================================================================================================


# Create:

#  the create method call will create and save a new record into the database:

@user = User.create(name: "Nouman", occupation: "ASE")
p @user
#<User id: 1, name: "David", occupation: "Code Artist", created_at: "2022-08-25 10:30:45", updated_at: "2022-08-25 10:30:45">


# Using the new method, an object can be instantiated without being saved:

user = User.new
user.name = "Shah"
user.occupation = "Code Artist"
p user

user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end

p user

******************************

Read :

@users = User.all
@users.each do |user|
  p user
end

user = User.first
p user

# return the first user named Nouman
nouman = User.find_by(name: 'Nouman')
p nouman

nouman = User.find_by(name: 'Nouhhman')
p nouman


# find all users named David who are Code Artists and sort by created_at in reverse chronological order
users = User.where(name: 'Nouman' , occupation: 'Code Artist').order(created_at: :desc)
users.each do |user|
  p user
end

user = User.first
user.send('name')     # get value of attribute 'name' from user

******************************

update:

user = User.find_by(name: 'Nouman')
user.name = 'Syed'
user.save


user = User.find_by(name: 'David')
user.update(name: 'Dave')

User.update_all "name = 'Nouman', occupation='seller' "


******************************

destroy:

user = User.find_by(name: 'Nouman')
user.destroy

# find and delete all users named David
User.where(name: 'Nouman').destroy_all

# delete all users
User.destroy_all


******************************

<h1>Listing Users</h1>
<table  >
  <tr>
    <th>ID</th>
    <th>Name</th>
    <th>Occupation</th>
  </tr>

  <% @users.each do |user| %>
  <tr>
    <td><%= user.id %></td>
    <td><%= user.name %></td>
    <td><%= user.occupation %></td>
  </tr>
  <% end %>
</table>

*****************************
store array in database column:

create_table(:app_display_selected_shops_sections) do |t|
  t.string(:shop_category_ids)

  t.timestamps
end
**********
class SelectedShopsSection < ApplicationRecord
  serialize :shop_category_ids, Array
end
**********
In Rails, the code serialize :shop_category_ids, Array is used to define a column in a database table to store an array of values.
It utilizes the serialization feature provided by ActiveRecord, the ORM (Object-Relational Mapping) framework used in Rails.

By using the serialize method, you can store an array of values in a single column of a database table.
In this specific example, the column being defined is named shop_category_ids, and it will store an array of values.
**********



******************************

make your own action:

1) just create action in controller
2) add route to that action
3) create template with action_name.html.erb


***********************
more on queries:
https://guides.rubyonrails.org/v5.2/active_record_querying.html


========================================================================================================================================================================
Migrations*
========================================================================================================================================================================


https://guides.rubyonrails.org/v5.2/active_record_migrations.html


Migrations:

Migrations alow you to use an Ruby DSL to describe changes to your tables -

Create Migration , alter table

rails g migration migration_name

***************


if you want to change the structure of db table you need to create a migration file alone ( we can change more than one table in one migration file )

1) rails generate migration changes_to_tables

2) write down changes:

def change
	add_column :books, year, :integer
	rename_column :students, :name, :student_name
	remove_timestamps :students
end



3) rake db:migrate

4) see refresh sqlite table

if you want more changes , you need to create another migration file


***********************

If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use reversible.

You can also use the old style of migration using up and down methods instead of the change method.
The up method should describe the transformation you'd like to make to your schema,
and the down method of your migration should revert the transformations done by the up method.

***********************


1)
add column part_number of string type in products:
add_column :products, :part_number, :string

change_table :books do |t|
  t.integer :rating, inclusion: 0..100
end

add_column :products, :price, :decimal, precision: 5, scale: 2

add_column :users, :username, :string, null: false, default: '', index: true, unique: true

add_column :accounts, :active, :boolean, default: true

add_column :user_scores, :created_at, :datetime, null: false, default: -> { 'CURRENT_TIMESTAMP' }
add_column :user_scores, :updated_at, :datetime, null: false, default: -> { 'CURRENT_TIMESTAMP' }

access value of CURRENT_TIMESTAMP:
-> current_timestamp = ActiveRecord::Base.connection.select_value('SELECT CURRENT_TIMESTAMP')
-> puts current_timestamp

2)  add_index :products, :part_number
    add_index :users, :cnic, unique: true

3)  remove_column :products, :part_number, :string

remove_column :posts, :slug, :string, null: false, default: '', index: true

4) create_table :products do |t|
      t.string :name
      t.string :part_number
    end

5) Add User Ref To Products
add_reference :products, :user, foreign_key: true


6) change_table, used for changing existing tables.
To removes the description and name columns, creates a part_number string column and adds an index on it. Finally it renames the upccode column.

change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end

change_table :products do |t|
	t.string :part_number,:description
	t.index :part_number
end


7) change_column :products, :part_number, :text

This changes the column part_number on products table to be a :text field. Note that change_column command is irreversible.

8)
This sets :name field on products to a NOT NULL column and the default value of the :approved field from true to false.

change_column_null :products, :name, false
change_column_default :products, :approved, from: true, to: false
change_column_default :questions, :text, from: nil, to: ''



9) drop_table :distributors

10)  It is wise to perform the transformations in down method in precisely the reverse order they were made in the up method

a)
			def up
				add_column :products, :price, :decimal, precision: 5, scale: 2
				rename_column :products, :part_number, :part_type
			end

			def down
				rename_column :products, :part_type, :part_number
				remove_column :products, :price
			end
b)
			def up
				add_column :products, :ssl_enabled, :boolean, default: true
			end

			def down
				remove_column :products, :ssl_enabled
			end



11)  drop_join_table :categories, :products

12)  you can execute your own query to alter table

13)  Joins table unique index validation:
add_index :user_topics, %i[user_id topic_id], unique: true


Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1")

14)
class CreateSelectedShopsSectionsShopCategoriesJoinTable < ActiveRecord::Migration[6.0]
  def change
    create_join_table(:app_display_selected_shops_sections, :shop_categories) do |t|
      t.index :app_display_selected_shops_section_id, name: "app_display_selected_shops_section_id_index"
      t.index :shop_category_id, name: "shop_category_id_index"
    end
  end
end

***********************

specify null:

In Rails migrations, if you do not specify the null option when adding a column,
the default behavior is to set null: false. This means that the column will not allow NULL values.

If you want the column to allow NULL values, you need to explicitly specify null: true in the migration.

So, the default value of null is false if you do not provide a value for it in the migration.


***********************

create_table(:content_components) do |t|
  t.integer(:association_type, null: false, default: 0)
  t.boolean(:active, null: false, default: false)
  t.integer(:rank, null: false, index: { unique: true })
  t.integer(:cell_structure, null: false, default: 1)
  t.string(:name_en, default: "")
  t.string(:name_ar, default: "")
  t.attachment(:icon)

  t.timestamps
end

***********************

This migration uses command, which is not automatically reversible.
To make the migration reversible you can either:
1. Define #up and #down methods in place of the #change method.
2. Use the #reversible method to define reversible behavior.


**********************

If you specify a target version, Active Record will run the required migrations (change, up, down) until it has reached the specified version.

->  rails db:migrate VERSION=20220825162220

case 1) If version 20080906120000 is greater than the current version (i.e., it is migrating upwards), this will run the change (or up) method on all migrations up to and including 20080906120000, and will not execute any later migrations.

case 2) If migrating downwards, this will run the down method on all the migrations down to, but not including, 20080906120000

*********************

-> For example, if rails db:migrate:status initially displays:

  (... some older migrations ...)
  up      20181001002039  Some migration description
  up      20181002222222  Some migration description
  up      20181003171932  Some migration description
  up      20181004211151  Some migration description
  up      20181005151403  Some migration description
Running:

-> rake db:migrate VERSION=20181002222222   Will result in:

  (... some older migrations ...)
  up      20181001002039  Some migration description
  up      20181002222222  Some migration description
  down    20181003171932  Some migration description
  down    20181004211151  Some migration description
  down    20181005151403  Some migration description

**********************

rake db:migrate:status

**********************

Rollback:

A common task is to rollback the last migration. For example, if you made a mistake in it and wish to correct it.
Rather than tracking down the version number associated with the previous migration you can run:

rails db:rollback

**********************

rails db:rollback STEP=3
will revert the last 3 migrations.

**********************

In order to rollback ONLY ONE specific migration (OUT OF ORDER) use::

rake db:migrate:down VERSION="20140311142212"

rake db:migrate:down VERSION="20230124132653"

rake db:migrate:down VERSION="20230123182829"

**********************

And if you ever want to migrate a single migration out of order:

rake db:migrate:up VERSION=20100905201547


**********************


https://stackoverflow.com/questions/3647685/how-to-rollback-a-specific-migration

Note: we can migrate down specific migration, then change it, and then migrate it again.


rake db:rollback STEP=1
Is a way to do this, if the migration you want to rollback is the last one applied. You can substitute 1 for however many migrations you want to go back.

For example:

rake db:rollback STEP=5
Will also rollback all the migration that happened later (4, 3, 2 and also 1).

To roll back all migrations back to (and including) a target migration, use: (This corrected command was added AFTER all the comments pointing out the error in the original post)

rake db:migrate VERSION=20100905201547


In order to rollback ONLY ONE specific migration (OUT OF ORDER) use:
rake db:migrate:down VERSION=20100905201547

Note that this will NOT rollback any interceding migrations -- only the one listed. If that is not what you intended, you can safely run rake db:migrate and it will re-run only that one, skipping any others that were not previously rolled back.

And if you ever want to migrate a single migration out of order, there is also its inverse db:migrate:up:
rake db:migrate:up VERSION=20100905201547


***************************

In case of error adding null: false to foreign key:
  rails db:drop
  rails db:create
  rails db:migrate
  rails db:seed

After rails db:drop:
we can change anything inside migration file, add of change anything or even delete migration.

****************************

remove version from schema_migrations:

rails db:migrate:status

Note the versions of the missing migrations and head into the db console:

rails dbconsole

Now remove the versions from the migration table manually:
delete from schema_migrations where version='<version>';


========================================================================================================================================================================
migrations2
========================================================================================================================================================================

rails g model user first_name:string{16} last_name:string email_address:string address_line_one address_line_two address_city address_state:string{2} address_zip:integer

rails db:migrate
rake db:seed

rails g migration AddIndexestoUsers
rails db:migrate
rails db:rollback
rails db:migrate db:rollback
rails db:migrate:down VERSION=20170828002007

************************


# 20170828002007_add_indexesto_users.rb
class AddIndexestoUsers < ActiveRecord::Migration[5.1]
  def up
    execute <<~SQL
    ALTER TABLE users
    ADD INDEX index_users_on_first_name (first_name),
    ADD INDEX index_users_on_last_name (last_name),
    ADD INDEX index_users_on_email_address (email_address),
    ADD INDEX index_users_on_address_zip (address_zip),
    ALGORITHM = INPLACE,
    LOCK = NONE
    SQL
  end

  # def change
  #   change_table :users, bulk: true do |t|
  #     t.index :first_name, algorithm: :inplace
  #     t.index :last_name, algorithm: :inplace
  #     t.index :email_address, algorithm: :inplace
  #     t.index :address_zip, algorithm: :inplace
  #   end
  # end

  **********************

  # def up
  #   add_index :users, :first_name
  #   add_index :users, :last_name
  #   add_index :users, :email_address
  #   add_index :users, :address_zip
  # end

  def down
    # raise ActiveRecord::IrreversibleMigration
    remove_index :users, :first_name
    remove_index :users, :last_name
    remove_index :users, :email_address
    remove_index :users, :address_zip
  end
end


************************


bulk: true

 means the schema changes will be squashed into one.

def change
    change_table :users, bulk: true do |t|
      t.integer :new_column1
      t.string  :new_column2
      t.boolean :new_column3
    end
end

************************

Create model and then revert it:

rails g model abc name
rails db:migrate

rails db:rollback
rails d model abc name


========================================================================================================================================================================
Validations*
========================================================================================================================================================================


Validations:

validation should be used with your model file

we can directly add validation in Modal class and it will applied automatically

****************************

rails generate model Student name:string

****************************

The following methods trigger validations, and will save the object to the database only if the object is valid:

create
create!
save
save!
update
update!

The bang versions (e.g. save!) raise an exception if the record is invalid. The non-bang versions don't: save and update return false, and create just returns the object.

********************

s = Student.new(name: "John Doe")
s.new_record?
s.save
s.new_record?

*********************

1) validates :name, presence: true                               # one field
   validates :name, :login, :email, presence: true               # more than one field
   validates :name, :login, :email, on: :create                  # on specific action

  Student.create(name: "John Doe").valid? # => true
  Student.create(name: nil).valid? # => false

2)   Note that an object instantiated with new will not report errors even if it's technically invalid,
       because validations are automatically run only when the object is saved, such as with the create or save methods.

rails c

p = Student.new
# => #<Student id: nil, name: nil>

>> p.errors.messages
# => {}

>> p.valid?
# => false

>> p.errors.messages
# => {name:["can't be blank"]}

>> p = Student.create
# => #<Student id: nil, name: nil>

>> p.errors.messages
# => {name:["can't be blank"]}

>> p.save
# => false

>> p.save!
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Student.create!
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank


3)

validates :name, length: { minimum: 2 }
validates :bio, length: { maximum: 500 }
validates :password, length: { in: 6..20 }
validates :registration_number, length: { is: 6 }
validates_numericality_of :field_name, :in => 1..99


4)  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,    message: "only allows letters" }

Alternatively, you can require that the specified attribute does not match the regular expression by using the :without option.


5) validates :name, absence: true

ensure that the name field is not given.
give error RecordInvalid (Validation failed: Name must be blank) if we give name


5)
validates :name, uniqueness: true

check that name should not present in database


6)  validates :age, numericality: true


*************************

student =  Student.new
student.valid?                 # => false
student.errors.messages
                            # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}

*************************

student =  Student.new(name: "JD")
student.valid? # => false
student.errors[:name] # => ["is too short (minimum is 3 characters)"]

*************************

student.errors.full_messages
student.errors.full_messages

<ul>
  <% @article.errors.full_messages.each do |msg| %>
  <li><%= msg %></li>
  <% end %>
</ul>


**************************
Custom Validations:
**************************

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.name == "Nouman"
      record.errors[:base] << "This person is Nouman"
    end
  end
end

class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:base] << 'Need a name starting with X please!'
    end
  end
end

class Student < ApplicationRecord
  # validates :name, presence: true, allow_blank: true
  # validates :name, presence: true
  # validates :name, absence: true
  # validates :name, uniqueness: true
  # validates :name, numericality: true
  # validates_with GoodnessValidator
  # validates_with MyValidator
  # validates :name, presence: true, length: { minimum: 3 }
  # validates :name, presence: { message: "name must be given please" }

  validate :custom_method

  def custom_method
    if self.age < 18
      errors.add(:age, "age should be greater than 18")
    end
  end

end


========================================================================================================================================================================
Form field validations:
========================================================================================================================================================================
number_field_tag:
<%= form.number_field :quantity, step: 5, min: 0, max: 999999999999 %>
https://apidock.com/rails/ActionView/Helpers/FormTagHelper/number_field_tag

text field:
https://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html#method-i-text_field_tag


https://guides.rubyonrails.org/form_helpers.html


number_field_tag 'quantity', nil, in: 1...10
<input id="quantity" name="quantity" min="1" max="9" type="number" />

maxlength vs size:
maxlength is used to indicate the number of characters that can be entered in the input field regardless of how large the fields appears on the screen.
The size attribute determines how wide the field will be on the screen.

<%= text_field_tag 'create_text', nil, :maxlength => 15, :size => 40 %>

========================================================================================================================================================================
Day 4
========================================================================================================================================================================


*******************************
Controller Callbacks
*******************************


rails g scaffold Student name:string
rails db:migrate


Filters are methods that are run "before", "after" or "around" a controller action.

*****************

Filters are inherited, so if you set a filter on ApplicationController, it will be run on every controller in your application.
"before" filters may halt the request cycle.

class ApplicationController < ActionController::Base
  before_action :require_login

  private

  def require_login
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # halts request cycle
    end
  end
end

*****************

You can prevent this filter from running before particular actions with skip_before_action:

class LoginsController < ApplicationController
  skip_before_action :require_login, only: [:new, :create]
end

The :only option is used to skip this filter only for these actions, and there is also an :except option which works the other way.


*****************************************************

https://stackoverflow.com/questions/36143039/rails-around-action-in-the-callback-stack

around_action are more like append_before_action + prepend_after_action.

Internally, think of it like rails has two arrays, @before_actions and @after_actions.
 So when you declare around_action, it pushes/appends it to the end of @before_actions and it unshift/prepends to the @after_actions.

With a quick test as follows:

class SomeController < ApplicationController
  before_action :before_action
  after_action :after_action
  around_filter :around_action

  def before_action
    $stderr.puts "From before_action"
  end

  def after_action
    $stderr.puts "From after_action"
  end

  def around_action
    begin
      $stderr.puts "From around_action before yielding"
      yield
      $stderr.puts "From around_action after yielding"
    end
  end

  def index
  end
end


I got the following in the log:

Started GET "/" for 127.0.0.1 at 2016-03-21 17:11:01 -0700
Processing by SomeController#index as HTML
From before_action
From around_action before yielding
  Rendered some/index.html.slim within layouts/index (1.5ms)
From around_action after yielding
From after_action



========================================================================================================================================================================
notes Action Controller
========================================================================================================================================================================

Action Controller is concerned with communicating with the database and performing CRUD actions where necessary.

***********************8

resource based routing

resources :student will generate all the routes for CRUD operations

HTTP verbs

POST    - Create
GET     - Read
PUT	 - UPdate
DELETE  -Destroy


The naming convention of controllers in Rails favors pluralization of the last word in the controller's name,
although it is not strictly required (e.g. ApplicationController). For example, ClientsController is preferable to ClientController,
 SiteAdminsController is preferable to SiteAdminController or SitesAdminsController, and so on.

The controller naming convention differs from the naming convention of models, which are expected to be named in singular form.

*******


There are two kinds of parameters possible in a web application.
1) query string (  after the ? in the url)
2) The second type of parameter is usually referred to as POST data. This information usually comes from an HTML form which has been filled in by the user.

Rails does not make any distinction between query string parameters and POST parameters, and both are available in the params hash in your controller:


========================================================================================================================================================================
params notes
========================================================================================================================================================================

http://localhost:3000/params/index?status=activated

# {"status"=>"activated", "controller"=>"params", "action"=>"index"}

puts "params:"
p params[:controller]
p params[:status]
p params[:action]


**********************


get 'params/new'
post 'params/create'



========================================================================================================================================================================
Session   , Flash  , Cookies
========================================================================================================================================================================


https://guides.rubyonrails.org/v5.2/action_controller_overview.html#session

Sessions:
Your application has a session for each user in which you can store small amounts of data that will be
 persisted between requests.

session[:user_id] = user.id

session[:user_id] = nil

******************

Flash:
The flash is a special part of the session which is cleared with each request.
 This means that values stored there will only be available in the next request, which is useful for passing error messages etc.

flash[:notice] = "You have successfully logged out."

<% flash.each do |name, msg| -%>
	<%= content_tag :div, msg, class: name %>
<% end -%>


#  'keep' to make it persist for another request.
 def index
    # Will persist all flash values.
    flash.keep

    # You can also use a key to keep only some kind of value.
    # flash.keep(:notice)
    redirect_to users_url
  end



By default, adding values to the flash will make them available to the next request, but sometimes you may want to access those values in the same request.For example, if the create action fails to save a resource and you render the new template directly, that's not going to result in a new request, but you may still want to display a message using the flash.

flash.now[:error] = "Could not save client"
render action: "new"

******************

Cookies:

Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions.
 Rails provides easy access to cookies via the cookies method, which - much like the session - works like a hash:


 cookies[:commenter_name] = @comment.author
 cookies.delete(:commenter_name)


 def set_cookie
    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014
    redirect_to action: 'read_cookie'
  end

  def read_cookie
    cookies.encrypted[:expiration_date] # => "2014-03-20"
  end


**************************************

cheetsheet:

# Create flash (reset every new request)
flash[:success] = 'User created with success!'

# Create flash.now (reset every new view render)
flash.now[:error] = 'Please select s user!'

# Create session (reset every browser close)
session[:user_id] = user.id

# Check if session exist
session[:user_id].nil?

# Remove
session.delete(:user_id)

# Remove all
reset_session

# Create cookie (reset at expiration date)
cookies.permanent[:remember_token] = remember_token

# Encrypted cookie
cookies.permanent.encrypted[:user_id] = user.id

# Delete cookie
cookies.delete(:user_id)


************************************


The main difference, in Rails 3, is that when you use cookie[:foo] = 'bar' the user is able to see the value for the cookie, i.e. 'bar'.

When you use session[:foo] = 'bar' the value will be encrypted by rails and stored in the _myapp_session cookie.

You would use the cookie[] format when the information you want to store is not bound to the session, e.g. when the users selects the preferred language.

You would use the session[] format when you want to store information that is related to the current session, e.g. the id of the the user.


************************************


session/cookies will be destroid if we close browser .


========================================================================================================================================================================
Associations
========================================================================================================================================================================

In Rails, an association is a connection between two Active Record models.

Why do we need associations between models?
Because they make common operations simpler and easier in your code.


========================================================================================================================================================================
1 one_to_many_association
========================================================================================================================================================================

cheetsheet:
https://web-crunch.com/posts/understanding-active-record-associations

rails new Associations
rails g controller home index


************************************************************************************************************
one to many relationship:

summary:
  1) create simple parent model
  2) create child model with foreign key of parent
  3) add has_many statement in parent model
************************************************************************************************************

1)
rails g model Student name:string email:string
rails db:migrate

2)
rails generate model Blog title:string content:text student:references    ( we can manually add foreign key but this is better - this will also add belongsto statement in blog model)
rails db:migrate

3)
and add  in student model:
 has_many :blogs,



To do manually:
1)
add column in blog table in migration  --  t.references :student, foreign_key: true, null: false
and then add ( belongs_to :student ) in blog model
and add ( has_many :blogs ) to stuent model

2) or just add column in new migration:
add_reference :blogs, :student, foreign_key: true, null: false

3) add_column :blogs, :student_id, :integer, null: false


***********

Note:
use singular name with belongs_to :student            ( hint: use file name of the model class)
use plural name with   has_many :blogs                ( hint: use the table name in the database)

****************

class Student < ApplicationRecord
  has_many :blogs
end

class Blog < ApplicationRecord
  belongs_to :student
end

***************
understand links:

class Student < ApplicationRecord
  has_many :blogs, foreign_key: "student_id"
end

class Blog < ApplicationRecord
  belongs_to :student, foreign_key: "student_id"
end

std = Student.find(1)
std.blogs
SELECT  "blogs".* FROM "blogs" WHERE "blogs"."student_id" = 1
# this will match the id of that student with the blogs model column "student_id" and fetch all blogs that match.

bl = Blog.find(2)
bl.student
SELECT  "students".* FROM "students" WHERE "students"."id" = 1
# use my own foreign key attribute (student_id) , and match it with the id of all students and get the matched student

****************
test in console:

Create Students:
-> Student.create(name:"Nouman", email:"nouman@gmail.com")
-> Student.create(name:"Shahmeer", email:"shahmeer@gmail.com")
-> Student.create(name:"Farhan", email:"farhan@gmail.com")
-> Student.create(name:"Fatima", email:"fatima@gmail.com")

Create Blog for Student(id=1):
-> Blog.create(title:"std1 blog", content:"this is a blog", student_id: 1)

or
-> std = Student.find(1)
-> std.blogs.create(title:"std1 2nd  blog", content:"this is 2nd blog")

-> Blog.count
-> Student.count
-> std1 = Student.first
-> std1.blogs                   #  use blogs ( plural as menthion with has_many statement )

-> blog = Blog.last
-> std = blog.student
-> std
-> blog.student_id
-> blog.student.name             #  use student ( singular as menthion with belongs_to statement )

****************




========================================================================================================================================================================
2 many_to_many_association
========================================================================================================================================================================

************************************
has_and_belongs_to_many Association:
************************************

A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model.

Implementation summary :
    1) create two simple models
    3) add has_and_belongs_to_many statement in both models
    2) create a join_table which will associate both tables.

we will join student and course model:
************************************************************************************************************

https://guides.rubyonrails.org/v5.2/association_basics.html#has-and-belongs-to-many-association-reference


rails g model Course name:string description:text
rails db:migrate

1) add this to student model class
has_and_belongs_to_many :courses

2) add this to Course model class
has_and_belongs_to_many :students

3) generate migration to create join table:
rails g migration create_course_student_join_table

Add this to migration file:
create_join_table :courses , :students                -- use lexical order to create join table

rails db:migrate

-> this will create courses_students table in database

***********

Create Courses:
-> Course.create(name:"Bio", description:"Biology and science for males")
-> Course.create(name:"Math", description:"Math for 2nd year")
-> Course.create(name:"Physics", description:"Physics for 2nd year")

Associate records:
course1 = Course.find(1)
course2 = Course.find(2)
course3 = Course.find(3)

assign student a course:
std1 = Student.find(1)                        --  fetch student
std1.courses << course1                       --  assign student a course
std1.courses                                  -- fetch all courses of student
std1.courses << course2 << course3            -- assign multiple courses

Query understanding:
std1 = Student.find(1)
std1.courses
SELECT  "courses".* FROM "courses" INNER JOIN "courses_students" ON "courses"."id" = "courses_students"."course_id" WHERE "courses_students"."student_id" = 1 LIMIT 11


you can also assign courses to students:
course1 = Course.find(1)
std1 = Student.find(1)
std2 = Student.find(2)
std3 = Student.find(3)
std4 = Student.find(4)
course1.students << std2 << std3 << std4
course1.students
std1.courses.size                                   --  see count of courses of this student
std1.courses.find(2)                                -- find course with id=2


************************
To remove this relationship , generate a migration and drop join table:

drop_join_table :courses , :students

************************

Limitations of has_and_belongs_to_many association  :

( using join_table we cannot add extra attribute , or callbacks or validations to the ralationship table
 because we do not have model for that )

https://guides.rubyonrails.org/v5.2/association_basics.html#choosing-between-has-many-through-and-has-and-belongs-to-many


*********************************************************
has_many :through
*********************************************************
A has_many :through association is often used to set up a many-to-many connection with another model.
This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model.
This method will implement many to many relationship using third model

Implementation summary:
  1) create two simple models
  2) create third model with foreign keys of two other models and  we can add more attributes in this model if required
  3) Add has many and has_many through statement in both two models


we will join student and project model:
************************************************************************************************************

# create project model
rails g model project name:string description:text
rails db:migrate

1) creating relationship model b/w student and project with third model
rails g model student_project student:references project:references submission_date:date
rails db:migrate

2)  add this to student  model class:
has_many :student_projects
has_many :projects, through: :student_projects

3) add this to project model class:
has_many :student_projects
has_many :students, through: :s
tudent_projects

*****

std = Student.first
std.projects
Project.create(name: "Driver app")
Project.create(name: "School management app")
Project.count


StudentProject.create( student_id: 1, project_id: 1 , submission_date: Date.today + 20.days )
std = Student.find(1)
std.projects

p = Project.find(1)
p.students

*****
Use this syntax if you not have additional attributes for relationship model( but works fine in both cases):

std2 = Student.find(2)
p2 = Project.find(2)
std2.projects << p2

*****

uniqueness validation:

add_index :user_topics, %i[user_id topic_id], unique: true

*****

Project.joins(:student_projects).where(  project: { name: 'Driver app' }  )
Driver app

******

Query Understanding:

std2 = Student.find(2)
std2.projects

SELECT  "projects".* FROM "projects" INNER JOIN "student_projects"
ON "projects"."id" = "student_projects"."project_id"
WHERE "student_projects"."student_id" = ? LIMIT ?  [["student_id", 2], ["LIMIT", 11]]

========================================================================================================================================================================
3 one_to_one_associations
========================================================================================================================================================================

********************************************
has_one
********************************************

Implementation summary:
  1) generate simple parent model and a child model with foreign key of parent
  2) add has_one statement in parent model
************************************************************************************************************

rails g model Supplier name:string
rails db:migrate

rails g model Account account_number:string supplier:references
rails db:migrate

1) add ( has_one :account ) in parent model
both model msut use singular name for association

-> supplier = Supplier.create(name: "Nouman")

-> account = Account.create(account_number: 123, supplier_id: supplier.id)
or
-> supplier.create_account(account_number:123)

-> supplier.account
-> supplier.account.account_number

-> account.supplier
-> account.supplier.name



***************************************************
has_one :through
*********************************************************

Implementation summary:
    1) create one simple parent model ( department )
    2) create child model with foreign key of parent ( department:references )
    3) create third model with foreign ley of child  ( manager:references )
    4) add statement has_one and has_one_through in parent model
    5) add has_one statement in child model

https://guides.rubyonrails.org/v5.2/association_basics.html#the-has-one-through-association
************************************************************************************************************
A has_one :through association sets up a one-to-one connection with another model.
This association indicates that the declaring model (department) can be matched with one instance of another model by proceeding through a third model.
Use has_one_through when you want to associate two models using third model.

For examle:
If each Department has one Manager, and each Manager is associated with one Managerhistory,   or
if each   supplier has one account, and each account is associated with one account history,

In docs:
supplier = Department
Accout = manager
account history = manager history

***********

1) create models
rails g model department name:string
rails g model manager name:string email:string contact:string department:references
rails g model manager_history joining_date:date total_experience:integer manager:references
rails db:migrate

2) add this to department model
has_one :manager
has_one :manager_history, through: :manager

3) add  in manager model
  has_one :manager_history

4) add records:

dept1 = Department.create(name: "Production department")
dept2 = Department.create(name: "Accounts department")

manager = Manager.create(name: "Nouman", email: "noman@gmail.com" , contact: "03335465765", department_id: dept1.id)
manager.department

dept1.manager

manager_history = ManagerHistory.create( joining_date: Date.today - 100.days , total_experience: 2, manager_id: Manager.first.id)
manager_history.manager

manager = Manager.find(1)
manager.manager_history

dept1.manager_history

manager_history.department   --  give error bec there is not association that manager_history belongs to department
                                  so we cannt accesss department through manager_history

========================================================================================================================================================================
Polymorphic Association
========================================================================================================================================================================

we need Polymorphic Association when we multiple parent models are their for a single child
With polymorphic associations, a model can belong to more than one other model, on a single association.

For example, you might have a picture model that belongs to either an employee model or a product model.
If we do not use polimorphic association, we have a problem of missing foreig_key ( null=false  ) constraint of other model  ,
as we have only on parent associated with one record.

1)
Parents:
rails g model Article title:string text:text
rails g model News title:string text:text

Child:
rails g model Comment title:string commentable_type:string commentable_id:integer

rails db:migrate

2) add in comment model:
belongs_to :commentable, polymorphic:true

3) and in article and news model:
has_many :comments, as: :commentable


4)

Article.create(title:"article 1")
Article.create(title:"article 2")
News.create(title:"news 1")
article = Article.find(1)

article.comments.create(title: "comment for Article 1")
article.comments.create(title: "2nd comment ")

article.comments
article.comments[0].title

***

news = News.find(1)

news.comments.create(title: "comment for news 1")
news.comments                -- give array of all comments on this news
news.comments[0]             -- get first comment on that news

comment = Comment.last
comment.commentable
comment.commentable.title
comment.commentable.text




========================================================================================================================================================================
Self joins
========================================================================================================================================================================


rails g model Employee account employee_id:integer manager_id:integer
rails db:migrate

emp1 = Employee.create(:account => "emp1")
emp2 = Employee.create(:account => "emp2")
man1 = Employee.create(:account => "man1")
emp1.subordinates
emp1.manager

emp1 = Employee.find(1)

emp1.subordinates << emp2
emp1.manager = man1
emp1.subordinates


************************


In Self join association one model has relation with itself.
For example one user table can have list of all coach and player.
One coach can train many players. We will represent the association as:


rails g model User name:string

run migration:
add_column :users , :coach_id, :integer

class User < ActiveRecord::Base
  has_many :players, :class_name => "User",  :foreign_key => "coach_id"
  belongs_to :coach, :class_name => "User"
end


user1 = User.create(name:"Player1")
user2 = User.create(name:"Player2")
user3 = User.create(name:"Player3")

coach1 = User.create(name:"coach1")

user1.coach = coach1
user1.save

user2.coach = coach1
user2.save

user3.coach = coach1
user3.save


coach1.players
# match id of users with coach_id

user1.coach


========================================================================================================================================================================
dependent_options
========================================================================================================================================================================
https://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_many-label-Options


Docs are available here

Looks like the following options are supported:

nil - do nothing (default). if it is required to do nothing on deletion, nil (which is default behaviour) can also be used

:destroy - causes all the associated objects to also be destroyed.

:delete_all - causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).

:nullify - causes the foreign keys to be set to NULL. Callbacks are not executed.

:restrict_with_exception - causes an exception to be raised if there are any associated records.

:restrict_with_error - causes an error to be added to the owner if there are any associated objects.


========================================================================================================================================================================
seed
========================================================================================================================================================================


Data seeding is the process of populating a database with an initial set of data.
data seeding :  https://www.youtube.com/watch?v=eR07DB-GUJ8


create object and run rails db:seed will populate data to model

student = Student.create( name: "Nouman", email: "nouman@gmail.com")
 rails db:seed


*****************************
renderring in different formats
*****************************

  render plain: "OK"

  render html: helpers.tag.strong('Not Found')

  @grades = { "Jane Doe" => 10, "Jim Doe" => 6 }
  render json: @grades

  render xml: @grades

  render :file => 'public/404.html', :status => :not_found, :layout => false

  render status: 500


========================================================================================================================================================================
Day 5:

routes
========================================================================================================================================================================

member routes: routes that needs the id to perform action (like  show, edit, update destroy) ( acts on single object)

collection routes : routes that do not need id to perform action ( lik index, create , new)  ( acts on collection of obhects)

***************************

namespace routing is used when you want to organize group of controllers under a namespace

***************************

create controler in subdirectory:

rails g controller admin/Users


**********************************

https://www.youtube.com/watch?v=KmYt07MUh9c

http://localhost:3000/admin/sellers

rails g scaffold admin/Sellers name:string
rails db:migrate

rails g scaffold animals/Cat name:string age:integer
rails db:migrate

**********************************

or you can add existing controller in sub folder and then add Admin:: before controller class
and move routes under namespace
and at last we need to set the new links to our buttons

**********************************


# this will remove the admin prefix from the url and is still use controller in admin folder
scope  module: :admin do
  resources :students
end

Note: change links in case you change scope or namespace accordingly

**********************************

if you want admin prefix to your routes and not want the namespace
( i.e you want normal controller in Controller folder not in any sub folder)

scope :admin do
  resources :students
end


========================================================================================================================================================================
routes video Notes
========================================================================================================================================================================

get 'products', to: 'products#index', as: 'products'
# ^verb  ^URL       ^controller#action    ^ refer: products_path

get 'products/:id', to: 'products#show',  as: 'product' , id: /\d+/
# ^verb  ^URL         ^controller ^action    ^ refer: product_path, constraint (for numeric values only)


*****************

get 'form', to: 'welcome#form', as: 'form'

redirect_to :form
render "form"          -- can also use string

****

redirect_to action: 'form'

redirect_to(
      content_components_path,
      alert: "Cannot destroy associated content component"
    ) if @content_component.configured

*****************

link to index acion:

<a href="/products">Back</a>
<%= link_to 'Back', products_path %>

******************************

link to show acion of particular product:
 <!--   different ways to link_to our product from the most explicit to the most conventional. -->

<%= link_to 'Details', product_path(id: product.id) %>
<%= link_to 'Details', product_path(product) %>
<%= link_to 'Details', product %>

<a href="/products/<%= product.id %>">Details</a>


**********************

root 'products#index'

root to: 'products#index'

**********************

# Generate the 2 default RESTful routes for index and show.
resources :products, only: [:index, :show]

# create all routes except for index action ( no route for index)
resources :products, except: [:index]


********************

http://localhost:3000/about

get 'about' => 'products#about'

********************

get 'blog', to: redirect('https://guides.rubyonrails.org/v5.2/routing.html')

********************

shallow routes: (nested resources)

https://www.digitalocean.com/community/tutorials/how-to-create-nested-resources-for-a-ruby-on-rails-application

resources :questions do
    resources :answers, shallow: true
end


              questions GET       /questions(.:format)                                                                     questions#index
                        POST      /questions(.:format)                                                                     questions#create
            new_question GET      /questions/new(.:format)                                                                 questions#new
          edit_question GET       /questions/:id/edit(.:format)                                                            questions#edit
                question GET      /questions/:id(.:format)                                                                 questions#show
                        PATCH     /questions/:id(.:format)                                                                 questions#update
                        PUT       /questions/:id(.:format)                                                                 questions#update
                        DELETE    /questions/:id(.:format)                                                                 questions#destroy
        question_answers GET      /questions/:question_id/answers(.:format)                                                answers#index
                        POST      /questions/:question_id/answers(.:format)                                                answers#create
    new_question_answer GET       /questions/:question_id/answers/new(.:format)                                            answers#new
            edit_answer GET       /answers/:id/edit(.:format)                                                              answers#edit
                  answer GET      /answers/:id(.:format)                                                                   answers#show
                        PATCH     /answers/:id(.:format)                                                                   answers#update
                        PUT       /answers/:id(.:format)                                                                   answers#update
                        DELETE    /answers/:id(.:format)                                                                   answers#destroy


Shallow follows convention over configuration, and will shorten the URLs where possible.
Note that with the shallow rails option even the “edit” is taken out of the nest.

Only index, create, and new are left inside.

========================================================================================================================================================================
Day 6: ActionView  ||   action view

forms:
========================================================================================================================================================================

rails g model Post title:string body:text author:string

**********************************
https://medium.com/@michellekwong2/form-tag-vs-form-for-vs-form-with-fa6e0ac73aac
**********************************

form_tag generates an HTML form for us and lets you specify options you want for your form.
We use the rails method, url_for, to create a URL we want the form to submit to. This request for making a new post would have a URL of /posts and let Rails know the specific controller this URL is going to be for.

******


<%= form_tag url_for(action: 'create'), method: "post" do %>

  <%= label_tag 'Title' %>
  <%= text_field_tag 'title', @post.title %>

  <%= label_tag 'Body' %>
  <%= text_area_tag 'body', @post.body %>

  <%= label_tag 'Author' %>
  <%= text_field_tag 'author', @post.author %>

  <%= submit_tag "Create Post" %>

<% end %>


**********************************

form_for

form_for method follows RESTful conventions on its own. It accepts the instance of the model as an argument where it makes assumptions for you (which is why it can be seen to be preferred over form_tag).
form_for prefers the argument that you’re passing in to be an active record object. This will easily make a create or edit form.

<%= form_for @post , html: { class: "w-100", id: "", name: "" } do |f| %>
  <%= f.label :title %>
  <%= f.text_field :title %>
  <br>

  <%= f.label :body %>
  <%= f.text_area :body %>
  <br>

  <%= f.label :author %>
  <%= f.text_field :author %>
  <br>

  <%= f.submit %>
<% end %>

or

<%= form_for 'posts', url: post_path, method: 'POST' do |form| %>
<% end %>

**********************************


Know when to use form_for vs. form_tag

We use form_for with a specific model and use form_tag when you don’t have a model for it (for custom URLs).
Both form_for and form_tag produce HTML for a form.
However, the syntax for both forms is different since we use form builder field helpers with form_for but not with form_tag.
And then theres form_with where we always use form builder.


**********************************

form_with

If we don’t pass a model, form_with behaves like form_tag.

form_with submits are remote by default and attaches the data-remote=“true” to the form.
You can change this by using local: true. This is the opposite from the other methods where the default is local and you have to specify remote: true to make it remote.

Another difference between form_with compared to form_for and form_tag is that form_for and form_tag generate automatic ids for the input fields.
 On the other hand, form_with does not. Ids and classes have to be specified.

Lastly, another difference in form_with is that any id and class are not wrapped in the html key.
Example of form_with wrapping id & class in keys :

<%= form_with model: @post, id: “custom-id”, class: “custom-class” do |form| %>

as opposed to form_for where you have to specify the id and class:

<%= form_for @post, html: { id: “custom-id”, class: “custom-class” } do |form| %>


**************
https://api.rubyonrails.org/v5.2/classes/ActionView/Helpers/FormHelper.html#method-i-form_with

<%= form_with model: @post, local: true do |f| %>
  <%= f.label :title %>
  <%= f.text_field :title %>
  <br>

  <%= f.label :body %>
  <%= f.text_area :body %>
  <br>

  <%= f.label :author %>
  <%= f.text_field :author %>
  <br>

  <%= f.submit %>
<% end %>


**************
other form Tags


<div class="field form-group">
  <%= f.label :name %><br />
  <%= f.text_field :name , class:"form-control", placeholder:"Name"  ,autofocus: true, autocomplete: "name"   %>
</div>

******************

<div class="field form-group">
  <%= f.label :username %><br />
  <%= f.text_field :username , class:"form-control", placeholder:"Username" , autofocus: true, autocomplete: "username"   %>
</div>

******************

<div class="field form-group">
  <%= f.label :age %>
  <%= f.number_field :age, step: 1,  min: 0, max: 200, class:"form-control" , autofocus: true, autocomplete: "age" %>
</div>

******************
enum gender: { unknown: 0, male: 1, female: 2 }

<div class="field form-group" >
  <%= f.label :gender %>
  <%= f.select :gender, options_for_select(User.genders.collect { |s| [s[0].humanize, s[0]] }, selected: current_user.gender ), {}, class: "form-control" %>
</div>

******************

<div class="field form-group">
  <%= f.label :email %><br />
  <%= f.email_field :email, autofocus: true, autocomplete: "email", class:"form-control", placeholder:"Email" %>
</div>

*****************

create_table :products do |t|
    t.string :name, null: false
    t.string :size, default: "1-3, 3-6", null: false
    t.text :description, null: false
    t.string :model
    t.integer :quantity, default: 0, null: false
    t.decimal :price, precision: 5, scale: 2, default: "0.0", null: false
    t.boolean :status, default: true, null: false
    t.string "color", limit: 25, default: "", null: false

    t.references :user, foreign_key: true, null: false
    t.timestamps
end

<%= form_with(model: product, local: true) do |form| %>

  <% if product.errors.any? %>
    <div id="error_explanation " class="m-3 text-danger">
      <h2><%= pluralize(product.errors.count, "error") %> prohibited this product from being saved:</h2>
      <ul>
        <% product.errors.full_messages.each do |message| %>
          <li><%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field form-group">
    <%= form.label :name %>
    <%= form.text_field :name, maxlength: 35, class:"form-control" %>
  </div>

  <div class="field  form-group">
    <%= form.label :color %>
    <%= form.text_field :color, maxlength: 25, class:"form-control"  %>
  </div>

  <div class="field form-group">
    <%= form.label :price %>
    <%= form.number_field :price, step: 0.5,  min: 0, max: 999999999999, class:"form-control" %>
  </div>
  <div class="field form-group">
    <%= form.label :size %>
    <%= form.text_field :size, maxlength: 25  , class:"form-control" %>
  </div>
  <div class="field form-group">
    <%= form.label :quantity %>
    <%= form.number_field :quantity, min: 0, max: 999999999999  , class:"form-control"%>
  </div>
  <div class="field form-group">
    <%= form.label :description %>
    <%= form.text_area :description , maxlength: 250, class:"form-control"  %>
  </div>
  <div class="field form-group">
    <%= form.label :model %>
    <%= form.text_field :model , maxlength: 25, class:"form-control" %>
  </div>
  <div class="field">
    <%= form.label :active %>
    <%= form.check_box :active %>
  </div>
  <div class="field mb-4">
    <%= form.label :images %>
    <%= form.file_field :images , multiple: true %>
  </div>
  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>

******************
show errors in forms
******************

@content_component.errors.full_messages_for(:icon).join(", ")
@content_component.errors.full_messages.join(", ")

<div class="form-group">
  <div class="col-sm-2">
    <%= f.label(:name_ar, "Name in Arabic", class: "control-label") %>
  </div>
  <div class="col-sm-4">
    <%= f.text_field(:name_ar, class: "form-control toggle-edit-mrsool") %>
    <div class="error"><%= @content_component.errors.full_messages_for(:name_ar).join(", ") %></div>
  </div>
  <div class="clearfix"></div>
</div>



******************************
View Helpers   ( view helpers)
******************************

Simple:
https://guides.rubyonrails.org/action_view_helpers.html
Descriptive:
https://api.rubyonrails.org/classes/ActionView/Helpers.html


<% @date = Date.today %>

<%= @date.strftime('%A, %b, %d, %Y') %>

<%= formatted_date(@date)%>

<%= render_sample_button %>

<%= time_ago_in_words(Time.now)  %>

<%= number_to_human(10_000)  %>

<%= image_url("edit.png") %>

<%= stylesheet_url "application.css"  %>


******************

yield in application.html.erb

1) add in application.html.erb where you want to add data from special page:
  <%= yield :special_script %>


2) add data from specific html page:
<% content_for :special_script do %>
  <h2>Hey this is special view</h2>
<% end %>

********************

How to Use Helpers From Controllers
In newer versions( >= 5), you can use helpers in your controller with the helpers (plural) object.

class UsersController
  def index
    helpers.time_ago_in_words(Time.now)
  end
end

********************

How to Use Helpers From console


You can use helpers from the console with helper.method_name.

$ helper.time_ago_in_words(Time.now)

Notice the singular form of “helper” so you don’t get an error message. And remember that the console doesn’t reload code changes automatically.

***********************

options_from_collection_for_select:

options_from_collection_for_select is a Rails view helper method that creates a string of HTML options tags for a dropdown
select box based on a collection of objects.

The method takes four arguments:

collection - A collection of objects that will be used to create the dropdown options.
value_method - The method to be called on each object in the collection to determine the value of the option.
text_method - The method to be called on each object in the collection to determine the text displayed for the option.
selected (optional) - The value of the selected option.

The options_from_collection_for_select method iterates through each object in the collection,
  calls the value_method and text_method on it,
  and creates an HTML option tag with the value and text for that object.
  If a value matches the selected argument, it is marked as selected in the HTML output.

The resulting string of HTML option tags is then returned by the method and can be used in a dropdown select box.

Example:

Suppose you have a City model with id and name attributes, and you want to create a dropdown select box that allows users to choose a city. You can use options_from_collection_for_select to generate the HTML option tags for the dropdown like this:

<!-- Assume that @cities is a collection of City objects -->

<%= select_tag(:city_id, options_from_collection_for_select(@cities, :id, :name)) %>     ***

In this example, options_from_collection_for_select is called with three arguments:

@cities - A collection of City objects to create options for.
:id - The method to call on each City object to get the value of the option (in this case, the id attribute).
:name - The method to call on each City object to get the text for the option (in this case, the name attribute).

options_from_collection_for_select generates the HTML option tags for the dropdown select box based on the id and name attributes of the City objects in the @cities collection.

The resulting HTML output would look like this:

<select name="city_id" id="city_id">
  <option value="1">New York City</option>
  <option value="2">San Francisco</option>
  <option value="3">Los Angeles</option>
  <!-- more options... -->
</select>

-> run this in console to test options_from_collection_for_select:
include ActionView::Helpers::FormOptionsHelper

def self.test
  options = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  options_from_collection_for_select(options, :to_i, :to_s)
end

***********************

1 Overview of helpers provided by Action View
  1.1 AssetTagHelper
      1.1.1 auto_discovery_link_tag
      1.1.2 image_path
      1.1.3 image_url
      1.1.4 image_tag
      1.1.5 javascript_include_tag
      1.1.6 javascript_path
      1.1.7 javascript_url
      1.1.8 stylesheet_link_tag
      1.1.9 stylesheet_path
      1.1.10 stylesheet_url
  1.2 AtomFeedHelper
      1.2.1 atom_feed
  1.3 BenchmarkHelper
      1.3.1 benchmark
  1.4 CacheHelper
      1.4.1 cache
  1.5 CaptureHelper
      1.5.1 capture
      1.5.2 content_for
  1.6 DateHelper
      1.6.1 distance_of_time_in_words
      1.6.2 time_ago_in_words
  1.7 DebugHelper
  1.8 FormHelper   ( https://guides.rubyonrails.org/form_helpers.html )
  1.9 JavaScriptHelper
      1.9.1 escape_javascript
      1.9.2 javascript_tag
  1.10 NumberHelper
      1.10.1 number_to_currency
      1.10.2 number_to_human
      1.10.3 number_to_human_size
      1.10.4 number_to_percentage
      1.10.5 number_to_phone
      1.10.6 number_with_delimiter
      1.10.7 number_with_precision
  1.11 SanitizeHelper
      1.11.1 sanitize
      1.11.2 sanitize_css(style)
      1.11.3 strip_links(html)
      1.11.4 strip_tags(html)
  1.12 UrlHelper
      1.12.1 url_for
      1.12.1.1 Examples
      1.12.2 link_to
      1.12.3 button_to
      1.12.3.1 Examples
  1.13 CsrfHelper
undefined

********************************
button_to vs link_to
********************************

button_to:
button_to generates an HTML form element that includes a button.
 When this button is clicked, it sends a POST request to the server.
 This is typically used for actions that create, update, or delete resources.
<%= button_to "Delete", post_path(@post), method: :delete, data: { confirm: "Are you sure?" } %>

link_to:
link_to generates an HTML anchor (a) element, creating a hyperlink that users can click to navigate to a different page, URL, or resource.
<%= link_to "Read More", post_path(@post) %>

HTTP method in both:
button_to allows you to specify the HTTP method explicitly with the method option, which is often used for actions that modify server data (e.g., create, update, delete).

link_to typically triggers a GET request by default. However, you can use the method option to specify other HTTP methods, like POST, PUT, or DELETE, but it doesn't create a form.

========================================================================================================================================================================
access controller and action name in views:
========================================================================================================================================================================


https://stackoverflow.com/questions/1244921/rails-controller-action-name-to-string

*******************

controller name:

<%= controller.controller_name %>
return => 'users'

*******************

action name:
<%= controller.action_name %>
return => 'show'

*******************

id:
<%= ActionController::Routing::Routes.recognize_path(request.url)[:id] %>
return => '23'

========================================================================================================================================================================
Pagination
========================================================================================================================================================================
https://github.com/kaminari/kaminari

gem 'kaminari'
 bundle install



1) add in model class:
  paginates_per 5

2) IN controller:
  @articles = Article.all.page(params[:page])

3) add in index file
<%= paginate @articles %>

4) rails g kaminari:views bootstrap4


**********************************

It is A Tradeoff, Each one has its own advantages and disadvantages.

For Server Side Pagination:
your request time and data are reduced, as only a selected no of rows will be sent by the server.
browser required less memory hence faster to process like filter, map, reduce etc.(only for one page)


For Client Side Pagination:
As all data is present on client machine user can easily switch between back and forth.
filter, search, map, reduce is possible on whole data.
server get few requests as for search, filter, etc needed extra request and many iterations to the server.
So choose according to your specific requirements.


========================================================================================================================================================================
yield in views:
========================================================================================================================================================================

1) specify in application.html.erb
<%= yield :special_script %>

2) in views:
<% content_for :special_script do %>
  <h2>Hey this is special script</h2>
<% end %>

========================================================================================================================================================================
Day 7
Action queries
========================================================================================================================================================================

Use Day7/QueryInterface Project for Practice:

Article.count
Article.first
Article.last

Article.column_names
=>["id", "title", "text", "created_at", "updated_at"]


Article.ids
[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]


*******************

a= Article.find([9, 10])      #  find with id in  9 or 10
a[0].text

SELECT "articles".* FROM "articles" WHERE "articles"."id" IN (?, ?)  [["id", 9], ["id", 10]]


Article.take(2)    # get first two records

Article.first

Client.first(3)
SELECT  "clients".* FROM "clients" ORDER BY "clients"."id" ASC LIMIT ?  [["LIMIT", 3]]

******************************

order:

Article.order(:title)              #  get all records order by title
Article.order(:id)                 #  get all records order by id
Article.order(:title).first        #   then fetch first record



Article.order(created_at: :desc)

Article.order(created_at: :asc)

Article.order("created_at DESC")

Article.order("created_at ASC")



************************************
select:
 Modifies the SELECT statement for the query so that only certain fields are retrieved:


1) Article.select(:id)
SELECT "articles"."id" FROM "articles"
=> #<ActiveRecord::Relation [#<Article id: 2>, #<Article id: 3>, #<Article id: 4>, #<Article id: 5>, #<Article id: 6>, #<Article id: 8>, #<Article id: 10>, #<Article id: 11>, #<Article id: 12>, #<Article id: 13>, ...]>

2) employees = Emp.select(:id, :ename, :sal)
will run: SELECT "emps"."id", "emps"."ename", "emps"."sal" FROM "emps"

employees.each do |emp|
  p emp.id
  p emp.ename
  p emp.sal
end

3) employees = Emp.select("emps.empno, emps.ename, emps.sal AS salary")
will run: SELECT emps.empno, emps.ename, emps.sal AS salary FROM "emps"

employees.each do |emp|
  puts "empno: #{emp.empno}, name: #{emp.ename}, salary: #{emp.salary}\n"
end

4) employees = Emp.select("ename || ' is a ' || job AS employee_description")
will run: SELECT ename || ' is a ' || job AS employee_description FROM "emps"

employees.each do |emp|
  p emp.employee_description
end

*************

Lab 2 questions for select:

15) Find the annual salary of the employees and sort it in descending order
Solution:

select ename, sal*12 as Annual_Salary from emp order by Annual_Salary desc

query_result = Emp.select("ename, sal * 12 AS Annual_Salary").order("Annual_Salary DESC")

query_result.each do |obj|
  p obj.Annual_Salary
end

SELECT  ename, sal * 12 AS Annual_Salary FROM "emps" ORDER BY Annual_Salary DESC LIMIT ?  [["LIMIT", 11]]

Lab 3:

3. Add 5 months in HireDate.
select ename,hiredate,add_months(hiredate,5) as output from emp

query_result = Emp.select("emps.ename, emps.hiredate, add_months(emps.hiredate, 5) as output")

query_result.each do |obj|
  puts "name: #{emp.ename}, hiredate: #{emp.hiredate}, output: #{emp.output}\n"
end


**********************************
calculate:

syntax:
calculate(operation, column_name)

Emp.calculate(:sum, :sal)
Emp.calculate(:sum, :sal)

Emp.calculate(:count, :all)

*********************************

pluck
pluck can be used to query single or multiple columns from the underlying table of a model.
return output in simple array
Pluck directly returns array of the attribute that we pass to it


Article.pluck(:id)    						# get only specified attributes

=> [2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 14]

Article.pluck(:id, :name, :dreams)

=> [[2, "name", "dreams"], [3, "name", "dreams"], [4, "name", "dreams"], [5, "name", "dreams"], [6, "name", "dreams"], [8, "name", "dreams"], [10, "name", "dreams"], [11, "name", "dreams"], [12, "name", "dreams"], [13, "name", "dreams"], [14, "name", "dreams"]]


* User.all.pluck(:id)
SELECT "users"."id" FROM "users"
 => [1, 2, 3, 4, 5]

* User.all.pluck(:name)
SELECT "users"."name" FROM "users"
  => ["Nouman", "Shah", "Sergei", "John", "mike"]

* User.all.pluck(:id, :name)
SELECT "users"."id", "users"."name" FROM "users"
 => [[1, "Nouman"], [2, "Shah"], [3, "Sergei"], [4, "John"], [5, "mike"]]

****************************

find_by

Article.find_by(id: 9)
Article.where(id:9).take          # same as above

Article.find_by!(id: 9)           # give error if record not found


************************************
where:

conditions ( where )


params = {id:10 }
Article.where("id= ?", params[:id])

params = {id:7 }
Article.where("id=? and title=?", params[:id], "Article 0")

Emp.where("ename = ? and sal > ?",'CLARK' ,1000)

Article.where(id:7)
Article.where(title:"Article 0")
Article.where("title" => "Article 0")     # we can also use string
Article.where.not(id:7)         # get all records where id is not 7

users = User.where(name: 'Nouman' , occupation: 'Code Artist').order(created_at: :desc)


User.where("id > ?", 200)
User.where("id > :id", id: 100)
Emp.where("sal > :abc", abc:1000)

************************

in:  pass array

Client.where(orders_count: [1,3,5])

This code will generate SQL like this:
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))

************************************

OR condition:

Article.where(id:1).or(Article.where(id:20))

 => SELECT  "articles".* FROM "articles" WHERE ("articles"."id" = ? OR "articles"."id" = ?)


******************************

Use Day7/QueryInterface Project:

rails g model client name:string orders_count:integer looked:boolean
rails g model address postcode:string client:references
rails g model order status:boolean client:references
rails db:migrate


*********************

present?:

present?:
The present? method, is a general-purpose method that is not specific to ActiveRecord.
It's used to check if an object is not nil and not empty.
This is useful for non-database-related objects or attributes.

  Example:
  # Check if a string is present (not nil and not empty)
  if employee.name.present?
    # Do something with the employee's name
  end

From the documentation:
An object is present if it’s not blank?.
An object is blank if it’s false, empty, or a whitespace string.

So, for example:

[ "", " ", false, nil, [], {} ].any?(&:present?)
# => false

User.where(name: 'mike').present?
SELECT "users".* FROM "users" WHERE "users"."name" = ?  [["name", "mike"]]
 => true

**********************

exists?

The exists? method is specifically designed for checking the existence of records in the database based on certain conditions.
It generates an efficient SQL query that only checks for the existence of records, without retrieving the actual data.
This can be more efficient when you only need to know if records meeting a certain condition exist, without fetching the entire record.

Example:

# Check if there are any employees with the job title 'MANAGER'
SELECT  1 AS one FROM "emps" WHERE "emps"."job" = ? LIMIT ?  [["job", "MANAGER"], ["LIMIT", 1]]

if Emp.exists?(job: 'MANAGER')
  # Do something if at least one 'Manager' employee exists
end

User.exists?(1)
SELECT  1 AS one FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 1], ["LIMIT", 1]]

User.exists?(id: [1,2,3])
SELECT  1 AS one FROM "users" WHERE "users"."id" IN (1, 2, 3) LIMIT 1

User.exists?(name: ['John', 'Sergei'])

User.where(name:"Nouman").exists?

User.exists?(name: 'mike')
SELECT  1 AS one FROM "users" WHERE "users"."name" = ? LIMIT ?  [["name", "mike"], ["LIMIT", 1]]

Note.create(:title => 'Hello, world.', :body => 'Nothing more for now...')
Note.exists?(1) # => true

**********************

exists? Vs present?

The big difference between the two methods, is that when you call present?
it initializes ActiveRecord for each record found(!), while exists? does not.

To show this I added after_initialize on User. it prints: 'You have initialized an object!'

User.where(name: 'mike').present?

SELECT "users".* FROM "users" WHERE "users"."name" = $1 ORDER BY users.id ASC  [["name", 'mike']]
You have initialized an object!
You have initialized an object!

User.exists?(name: 'mike')
SELECT 1 AS one FROM "users" WHERE "users"."name" = $1 ORDER BY users.id ASC LIMIT 1  [["name", 'mike']]

So, the choice between them depends on the context:
If you are specifically interested in checking the existence of records in the database based on certain conditions, exists? is a better choice for efficiency.
If you are working with non-database-related objects or attributes and you want to check if they are present, present? is the appropriate choice.

Use each method according to its intended purpose for cleaner and more maintainable code.

*********************

Calculations

count:
  User.count(:id)
  User.count("id")
  User.count(:age)


Average:
  Product.average(:price)
  Product.average("price")

Minimum:
  Product.minimum(:price)
  Product.minimum("price")

Maximum
  Product.maximum(:price)

Sum:
  Product.sum(:price)

***************

Emp.count - Emp.count(:sal)

*************************

Length:

Product.where("LENGTH(name) < 5")


*************************
scope in models:
*************************

syntax:
    scope :name, -> { where(:attibute => value)}

create scope in Product model class:
> scope  :laptops, -> { where( name:"Laptop") }

In console:
Product.laptops

****

Passing in arguments:

scope  :get_product, -> (name) { where( "name= ?", name) }

Product.get_product("Laptop")


************

anas:

scope :with_include, -> { includes(:purpose_of_transfer, :sender, :receiver) }
scope :with_detail, ->(data) { where('sender_id = ? or receiver_id = ?', data, data) }

@transfer_funds = TransferFund.with_detail(current_user.id).with_include

*************************
default_scope:
*************************

default_scope: this scope will be applied across all queries to the model

> default_scope { where("user_id IS NOT NULL") }
>Product.all.count


default_scope { order(id: :desc) }

*************************
scope with merge
*************************

scope in ShopCategory model without merge:

scope :shop_types, -> (shop_id) {
  joins(:shop_category_associations)
    .where(shop_category_associations: { shop_id: shop_id, association_type: :regular })
}

********

using merge:

1) scope in ShopCategory model:

scope :shop_types, -> (shop_id) {
    joins(:shop_category_associations).merge(ShopCategoryAssociation.by_shop_id(shop_id))
  }

2) add scope in ShopCategoryAssociation model:

scope :by_shop_id, -> (id) { where(shop_id: id, association_type: :regular) }

========================================================================================================================================================================
Group:
========================================================================================================================================================================

1) To get the total of grouped items on a single query, call count after the group.

Order.group(:status).count

SELECT COUNT(*) AS count_all, "orders"."status" AS orders_status FROM "orders" GROUP BY "orders"."status"
 => {false=>2, true=>4}

******************************************************

2) Product.group(:price).count
{0.334e1=>1, 0.8399e2=>1, 0.11334e3=>1, 1000=>3, 2000=>3}
it says that product with price 1000 are 3 and product with price 2000 are 3 and so on

******************************************************
a = Emp.group(:job)         -- group by job
a.count
a.count(:job)
a.count(:deptno)
a.count(:comm)
a.sum(:sal)                 -- give sum of salaries of each job
a.average(:sal)
a.maximum(:sal)             -- give maximum salary of each type of job

******************************************************

Emp.group(:job).count
SELECT COUNT(*) AS count_all, "emps"."job" AS emps_job FROM "emps" GROUP BY "emps"."job"
 => {"ANALYST"=>2, "CLERK"=>4, "MANAGER"=>3, "PRESIDENT"=>1, "SALESMAN"=>4}


******************************************************

3) Count Instances of each Job:
  Emp.group(:job).count(:job)
  SELECT COUNT("emps"."job") AS count_job, "emps"."job" AS emps_job FROM "emps" GROUP BY "emps"."job"
  => {"ANALYST"=>2, "CLERK"=>4, "MANAGER"=>3, "PRESIDENT"=>1, "SALESMAN"=>4}

******************************************************

4) Count Instances (record of emp) from each department :
Emp.group(:deptno).count(:deptno)
 SELECT COUNT("emps"."deptno") AS count_deptno, "emps"."deptno" AS emps_deptno FROM "emps" GROUP BY "emps"."deptno"
 => {10=>2, 20=>5, 30=>6, 50=>1}

******************************************************

5) Total sal of employess in each department:
Emp.group(:deptno).sum(:sal)

SELECT SUM("emps"."sal") AS sum_sal, "emps"."deptno" AS emps_deptno FROM "emps" GROUP BY "emps"."deptno"
 => {10=>0.745e4, 20=>0.10875e5, 30=>0.94e4, 50=>0.0}

******************************************************
6) Emp.group(:deptno, :job).sum(:sal)

SELECT SUM("emps"."sal") AS sum_sal, "emps"."deptno" AS emps_deptno, "emps"."job" AS emps_job FROM "emps" GROUP BY "emps"."deptno", "emps"."job"

select deptno, job, sum(sal) from emps group by deptno,job

=> {[10, "MANAGER"]=>0.245e4, [10, "PRESIDENT"]=>0.5e4, [20, "ANALYST"]=>0.6e4, [20, "CLERK"]=>0.19e4, [20, "MANAGER"]=>0.2975e4, [30, "CLERK"]=>0.95e3, [30, "MANAGER"]=>0.285e4, [30, "SALESMAN"]=>0.56e4, [50, "CLERK"]=>0.0}

this will give sum salaries for each job of each deptno
( see db register pg:40 )

******************************************************
Interpret Output Hash:
https://www.geeksforgeeks.org/ruby-hash-class/

result = Emp.group(:job).sum(:sal)

result.each {|key, value| puts  "the sum of all #{key} salary is #{value}" }
result.each_key {|key| puts key }
result.each_value{|value| puts value }
result.empty?
result.key?("ANALYST")
result.value?(6000)
result.length

========================================================================================================================================================================
Joins

project:
QueryInterface
========================================================================================================================================================================


why Joins?

Article.find(14).comments                                                    - get all comments of article 3  ( this will run 2 sql queries )

-> get the comments where the arycle title is  "Article 3" :

irb>    cmt = Comment.joins(:article).where(articles: {title: "Article 3" }).first

SELECT  "comments".* FROM "comments"
INNER JOIN "articles" ON "articles"."id" = "comments"."article_id"
WHERE "articles"."title" = ?
ORDER BY "comments"."id" ASC LIMIT ?  [["title", "Article 3"], ["LIMIT", 1]]

************

user = User.create(name:"NOuman")
user.products.create(name:"tv", price: 5000)

User.find(2).products.create(name:"Laptop", price:30000)

******************************************

simple Join or Inner Join:

select all products where user name is "NOuman:

products = Product.joins(:user).where(:users =>{:name => "Nouman" })
products = Product.joins(:user).where( users: {name: "Nouman" })           --  above query can be wriiten as this

SELECT "products".* FROM "products" INNER JOIN "users" ON "users"."id" = "products"."user_id" WHERE "users"."name" = ?  [["name", "Nouman"]]

products[0]
products[1]

******************************************


product = Product.joins(:user).where(users: {name: "NOuman" }).first
product


prod = Product.joins(:user)
prod.to_sql


*****************

Create product with not user:

p = Product.create(name:"prod1", price: 1234)
p.user

prod = Product.where(:user_id => nil)
prod

*****************

> user = User.create(name:"Farhan")

> User.where(name:"Farhan").joins(:products).where( :products => { :id=>nil} ).first
=> nil

Note:
Inner join connects foreign and primary key
Inner join excludes relations that don't exist in between the joined tables ( as above ).

***************************************************************

outer join:
Outer Join take all users and match them up with a product even if no matching product exists

> User.left_outer_joins(:products).where(:products=>{:id=>nil})

can be written as

> User.left_outer_joins(:products).where(products:{id:nil})

SELECT  "users".* FROM "users" LEFT OUTER JOIN "products" ON "products"."user_id" = "users"."id" WHERE "products"."id" IS NULL LIMIT ?  [["LIMIT", 11]]

Now this outer join has solved the problem

*********************

get product where user name is "Nouman" and product name is "laptop":

product1 = Product.joins(:user).where(  users: {name: "Nouman" },  products:{name: "Laptop"}  )
or
product = Product.where(name:"Laptop").joins(:user).where( users: {name: "Nouman" } )

***************************

find_by_sql

User.find_by_sql("SELECT * FROM users INNER JOIN products ON users.id = products.user_id ")

========================================================================================================================================================================
Join2
========================================================================================================================================================================

https://medium.com/swlh/getting-really-good-at-rails-joins-93fd5b33fa8e

models:
rails g model company name verified:boolean
rails g model Employee status name company:references
rails g model Location state country company:references


************************

load all active employees:
Employee.where(status: "active")

************************
Performance without joins:

But what if we want to load all active employees who belong to companies that are verified? Without joins, you would write something like this:

active_employees = Employee.where(status: "active")
result = active_employees.select do |employee|
  employee.company.verified?
end

Note: select is array method in ruby.

This isn’t great because it triggers an N + 1 query since it is looking in the database for a company record for each employee in the loop

************************
Improve quality using Joins:

We can easily improve the code above by using :joins.

Employee.where(status: "active").joins(:company).where(companies: { verified: true })

SELECT `employees`.* FROM `employees` INNER JOIN `companies`
ON `companies`.`id` = `employees`.`company_id`
WHERE `employees`.`status` = 'active' AND `companies`.`verified` = 1

************************

Let’s break this down even more

1) Employee.where(status: "active").joins(:company)
We would be loading all active employees who belong to a company. If an employee is not associated with a company, then they would not be returned. This is because :joins performs a SQL inner join by default.

2) Adding the clause where(companies: { verified: true }) scopes companies so that only employee’s with verified companies are returned. Note that this section of the query uses companies as a keyword since it is referring to the table name.

************************
other ways to write same above query:

Employee.where(status: "active").joins("INNER JOIN companies ON companies.id = employees.company_id WHERE companies.is_verified = 1")
Employee.joins("INNER JOIN companies ON companies.id = employees.company_id WHERE employees.status = 'active' AND companies.is_verified = 1")

************************
Now say company has many locations.
If we wanted to grab all employees who are at companies that have locations, we would perform the following query:

Employee.joins(company: [:locations]).distinct          # [] bracket cam be removed

SELECT DISTINCT "employees".* FROM "employees" INNER JOIN "companies" ON "companies"."id" = "employees"."company_id" INNER JOIN "locations" ON "locations"."company_id" = "companies"."id"

************************

Get active employees at companies that are verified in the state of California:

Employee.where(status: "active").joins(company: [:locations]).where(locations: { state: 'CA'}, companies: { verified: true })

************************
:includes

:includes  loads associated records in advance and limits the number of SQL queries made to the database.
 This technique is known as "eager loading" and in many cases will improve performance by a significant amount.

User.includes(:products).where(products: {name:"Laptop"})

************************

When to use :includes

:includes is a method in ActiveRecord used to preload data in order to avoid N + 1 queries.

Use :joins when you solely need to filter data based on associated tables
and use :includes if you need to reference data in associated tables later on.

For example, we’d want to use :includes if we were to load all active employees at companies that are verified
and then print each employee’s name and their company name.

employees = Employee.where(status: "active").includes(:company).where(companies: { verified: true })
employees.each do |employee|
  puts employee.name
  puts employee.company.name
  # puts "#{employee.name} works in #{employee.company.name} "
end

*********
same as :
Employee.where(status: "active").includes(company: [:locations]).where(locations: { state: 'CA'}, companies: { verified: true })


========================================================================================================================================================================
preload, includes, eager_load
========================================================================================================================================================================
https://www.bigbinary.com/blog/preload-vs-eager-load-vs-joins-vs-includes

In Rails, preload, includes, and eager_load are methods used for eager loading associations to optimize database queries and avoid the N+1 query problem.
These methods are part of ActiveRecord, the Rails ORM (Object-Relational Mapping) layer, and they serve slightly different purposes. Let's explore each one:



Preload:
-> loads the association data in a separate query.
-> The preload method loads the specified associations separately from the main query using a separate database query for each association.
 It loads all the associated records upfront, but it does not use any JOINs in the main query.
 Instead, it retrieves associated records through separate queries for each association.

Article.preload(:comments).where(articles: {title: "Article 3" })                 -- use two queries

Article Load (0.1ms)  SELECT  "articles".* FROM "articles" WHERE "articles"."title" = ? LIMIT ?  [["title", "Article 3"], ["LIMIT", 11]]
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."article_id" = ?  [["article_id", 3]]


********

Article.preload(:comments).where(comments: { commenter: "Nouman4" })              -- we cannot use where on 2nd table

*******************************************************

includes:

-> It  loads associated records in advance and limits the number of SQL queries made to the database.
 This technique is known as "eager loading" and in many cases will improve performance by a significant amount.

-> The includes method is similar to preload, but it can also use database JOINs in the main query to load the associated records.
It tries to minimize the number of database queries by using JOINs where possible.
If a JOIN is not possible or not recommended (e.g., due to a large number of associated records), it falls back to separate queries, similar to preload.


(run queries on day_7/QueryInterface)

User.includes(:products).where(products: {name:"Laptop"})


1) Article.includes(:comments)                                                       --  work as preload (using two queries )
Article Load (0.5ms)  SELECT  "articles".* FROM "articles" LIMIT ?  [["LIMIT", 11]]
Comment Load (0.2ms)  SELECT "comments".* FROM "comments" WHERE "comments"."article_id" IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)  [["article_id", 2], ["article_id", 3], ["article_id", 4], ["article_id", 5], ["article_id", 6], ["article_id", 8], ["article_id", 10], ["article_id", 11], ["article_id", 12], ["article_id", 13], ["article_id", 14]]

2) Article.includes(:comments).where(comments: { commenter: "Nouman" })              --  use left outer join when we use where or order command
SELECT  DISTINCT "articles"."id" FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE "comments"."commenter" = ? LIMIT ?  [["commenter", "Nouman"], ["LIMIT", 11]]
SELECT "articles"."id" AS t0_r0, "articles"."title" AS t0_r1, "articles"."text" AS t0_r2, "articles"."created_at" AS t0_r3, "articles"."updated_at" AS t0_r4, "comments"."id" AS t1_r0, "comments"."commenter" AS t1_r1, "comments"."body" AS t1_r2, "comments"."article_id" AS t1_r3, "comments"."created_at" AS t1_r4, "comments"."updated_at" AS t1_r5 FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE "comments"."commenter" = ? AND "articles"."id" IN (?, ?)  [["commenter", "Nouman"], ["id", 3], ["id", 2]]


3) Article.includes(:comments).references(:comments)                                 --  forcefully run in single query
SELECT  DISTINCT "articles"."id" FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" LIMIT ?  [["LIMIT", 11]]

4) Article.all.includes(:comments).where(articles: {title: "Article3" })
SELECT  "articles".* FROM "articles" WHERE "articles"."title" = ? LIMIT ?  [["title", "Article3"], ["LIMIT", 11]]


5) Article.all.includes(:comments).where(comments:{article_id: 2 })
SELECT  DISTINCT "articles"."id" FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE "comments"."article_id" = ? LIMIT ?  [["article_id", 2], ["LIMIT", 11]]


6) Comment.includes(:article).where(articles: {title: "Article 3" }).first
SELECT  "comments"."id" AS t0_r0, "comments"."commenter" AS t0_r1, "comments"."body" AS t0_r2, "comments"."article_id" AS t0_r3, "comments"."created_at" AS t0_r4, "comments"."updated_at" AS t0_r5, "articles"."id" AS t1_r0, "articles"."title" AS t1_r1, "articles"."text" AS t1_r2, "articles"."created_at" AS t1_r3, "articles"."updated_at" AS t1_r4 FROM "comments" LEFT OUTER JOIN "articles" ON "articles"."id" = "comments"."article_id" WHERE "articles"."title" = ? ORDER BY "comments"."id" ASC LIMIT ?  [["title", "Article 3"], ["LIMIT", 1]]


************

Eager load:

-> Eager loading loads all association in a single query using LEFT OUTER JOIN.

-> The eager_load method is similar to includes but always uses JOINs in the main query to fetch associated records.
It does not fall back to separate queries like preload.
In some cases, it can be more efficient than includes when you know that using JOINs is preferable, or if you want to enforce JOINs for a specific query.

Article.eager_load(:comments).to_a

Article.eager_load(:comments).where(comments: { commenter: "Nouman" })

*************************
count / size / length:
*************************

length:

length is a method available for arrays and strings in Ruby on Rails.

For arrays, it returns the number of elements in the array.
For strings, it returns the number of characters in the string.

****************

count:

count is a method available for arrays and ActiveRecord relations in Ruby on Rails.

For arrays, it returns the number of elements that match a given condition if a block is provided. If no block is provided, it returns the total number of elements in the array.
For ActiveRecord relations, count is used to perform a SQL COUNT query on the database to get the number of rows that match the conditions in the relation.

Post.where(published: true).count

****************

size:

size is a method available for arrays and ActiveRecord relations in Ruby on Rails.

For arrays, it behaves the same as length, returning the number of elements in the array.
For ActiveRecord relations, size is used to fetch all the records from the database and count the number of rows locally in Ruby.

This is different from count, which directly performs a SQL COUNT query on the database without fetching all the records.

Post.where(published: true).size

****************

In summary:

Use length or size for arrays, as they both give you the number of elements in the array. size may be preferred in some cases for its consistency with ActiveRecord relations.
Use count for ActiveRecord relations when you want to perform a SQL COUNT query on the database, especially if you only need the count and not the actual records.
count is generally more efficient than size in this context.


Length:
Get all records and count them locally.
If all entries are already loaded in the memory (Job.all), then use length to avoid another database query.

Count:
If you do not have anything loaded in the memory, use count to make a query on database.
Everytime it use sql count query to get result

Size:
if the collection has already been loaded in the memory, it will return the length same as calling length.
If it has not been loaded yet, it is like calling count.

*********

Examples:

size:

u = User.all
u.size
# run "SELECT COUNT(*) FROM `users` WHERE `users`.`is_deleted` = FALSE" every time

****
length:

u = User.all
u.length
# run -> SELECT `users`.* FROM `users` WHERE `users`.`is_deleted` = FALSE and count records locally
# Next time it will not run any query and return count directly

****
count:

Without block it is same as size:
u = User.all
u.count
run -> SELECT COUNT(*) FROM `users` WHERE `users`.`is_deleted` = FALSE every time


With block it fetches all the records and then count as per the block condition locally:
u = User.all
u.count { |obj| obj.id.even? }
run -> "SELECT `users`.* FROM `users` WHERE `users`.`is_deleted` = FALSE"

****************************
case expression in rails sql (in Lab 4)
****************************

employees = Emp.select(
  :empno,
  :ename,
  :sal,
  "CASE
    WHEN sal >= 3000 THEN 'High'
    WHEN sal >= 1000 THEN 'Moderate'
    ELSE 'Low'
    END AS salary_category"
)

employees.each do |emp|
  puts "Employee ID: #{emp.empno}"
  puts "Name: #{emp.ename}"
  puts "Salary: #{emp.sal}"
  puts "Salary Category: #{emp.salary_category}"
  puts "\n"
end

Lab 4)
19. Increase the salaries using CASE Expression of Clerks like dept no. 10
clerks will incread 15% and depnt no. 20 will increase 18% and dept no. 30
will have increase of 20%. And then find the one year salary.

Sol in raw sql:                     *****

SELECT ename,sal,deptno,
case deptno
  when 10 then sal+ (sal*15)/100
  when 20 then sal + (sal*18)/100
  when 30 then sal + (sal*20)/100
else sal end "revised salary"
from emp
where job='CLERK'

Sol in rails:                        *****

employees = Emp.select(
  :ename,
  :sal,
  :deptno,
  "CASE deptno
    WHEN 10 THEN sal + (sal*15)/100
    WHEN 20 THEN sal + (sal*18)/100
    WHEN 30 THEN sal + (sal*20)/100
    ELSE sal
    END AS revised_salary"
).where(job: "CLERK")


employees.each do |emp|
  puts "Name: #{emp.ename}"
  puts "Dept No.: #{emp.deptno}"
  puts "Salary: #{emp.sal}"
  puts "Revised Salary: #{emp.revised_salary}"
  puts "\n"
end

========================================================================================================================================================================
day 8
devise setup
========================================================================================================================================================================

https://rubygems.org/
https://rubygems.org/gems/devise

devise gem:
  Devise is the cornerstone gem for Ruby on Rails authentication. With Devise, creating a User that can log in and out of your application is so simple
  because Devise takes care of all the controllers necessary for user creation ( users_controller ) and for user sessions ( users_sessions_controller ).

Go to https://rubygems.org/   and search for devise

1) copy gem to gemfile  ( gem 'devise', '~> 4.8', '>= 4.8.1'  )
Go to its doc at github https://github.com/heartcombo/devise


2) bundle install will install all the gems in the gemfile

3) rails generate devise:install

complete instructions

4) rails g devise:views

5) rails generate devise user    ( this is migration command )
   rails db:migrate              ( migrate )

Add links to navbar and style each page with bootstrap

*****************
Note: User model Callbacks

update user model callbacks carefully,
overriding after_commit callback will not send email on signup

******************

fake email
https://www.mailinator.com/v4/public/inboxes.jsp?trialshow=true&to=nouman


==================================================================================================================================
Update Devise User ( configure devise)
==================================================================================================================================


https://github.com/heartcombo/devise#strong-parameters

1) create migration to add fields:
def change
    add_column :accounts, :website, :string
    add_column :accounts, :bio, :text
end


2) Allow new params attributes in application controller

before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_up, keys: [:name])
    devise_parameter_sanitizer.permit(:account_update, keys: [:name, :website, :bio])
  end

3) add fields in views

********************
add gender:

https://zhangjingqiang.wordpress.com/2015/03/30/how-to-add-a-gender-column-to-user-model-under/

****************************************
Devise controllers:
****************************************

https://stackoverflow.com/questions/6234045/how-do-you-access-devise-controllers

rails generate devise:controllers users

devise_for :users,controllers: {
  registrations:'users/registrations'
}


name, age, gender, email, username, and profile picture

========================================================================================================================================================================
active storage:
========================================================================================================================================================================

devise user image:
https://www.youtube.com/watch?v=BYvzLYRIZK4

multiple images:
https://www.youtube.com/watch?v=A23zCePXe74

*****************************

for validations we can use gem:
https://github.com/igorkasyanchuk/active_storage_validations

also add error messages in config/locals/en.yml

*****************************

rails active_storage:install
rails db:migrate

gem 'mini_magick', '~> 4.8'
sudo apt-get install imagemagick


*****************************

user= User.first

ActiveStorage::Blob.service.path_for(user.avatar.key)

"/home/dev/Rails/Day 8/Rails_Devise/storage/nN/yd/nNydy5Z9hY5evqt5oo44CYFT"

*****************************
home index:

<p><%= current_user.avatar.content_type.in?(%('image/jpeg image/png')) %></p>
<p><%= %('image/jpeg image/png') %></p>
<p><%= %w('image/jpeg image/png') %></p>


*****************************

devise edit:


<div class="field">
  <%= image_tag( resource.avatar_thumbnail) if resource.avatar.attached?  %><br />
</div>


========================================================================================================================================================================

day 9

Active Jobs
========================================================================================================================================================================

Active Job is a framework for declaring jobs and making them run on a variety of queueing backends.

******************************
Active Job is an interface to queueing backends such as sidekiq, delayed_job or resque.
 It's simply a way for you to write background jobs where you don't have to care about which of the queueing backends will be used.
******************************

rails g job first_job

GuestsCleanupJob.set(wait: 5.seconds).perform_later(2)

*****************************

Sidekiq is a Ruby Background Processor that manages its queue with a Redis service. Learn the basics of Sidekiq and integrating it with ActiveJob

1) gem 'sidekiq'
   bundle

2) config/application.rb:
config.active_job.queue_adapter = :sidekiq
config.active_job.queue_adapter =  Rails.env.production? ? :sidekiq : :async

3) create sidekiq.rb in config/initializers

4) rails g job generate_random_user

5) GenerateRandomUserJob.perform_later

6) in terminal run sidekiq sever:
    sidekiq

7) run rails server in production:
    rails s -e production

8) http://localhost:3000/sidekiq


https://www.youtube.com/watch?v=CStZg8ql9Vs
https://www.digitalocean.com/community/questions/how-to-run-rails-server-in-production-mode

9) rake db:migrate RAILS_ENV=production

https://stackoverflow.com/questions/4909831/rake-dbmigrate-doesnt-seem-to-work-in-production


*********************
Background Processing with Rails, Redis and Sidekiq
https://www.youtube.com/watch?v=GBEDvF1_8B8

*********************
https://stackoverflow.com/questions/32947076/redis-server-in-ubuntu14-04-bind-address-already-in-use

stop server is redis not worK:

sudo service redis-server stop

redis-server


# sleep(5.seconds)

# sleep(5.minutes)

# sleep(5.hours)

# sleep(5.days)

========================================================================================================================================================================
services and concerns
========================================================================================================================================================================

see Day9/activejobs **

we write re usable modules in concerns

A rail concern is any module that extends ActiveSupport::Concern module

concerns
https://www.youtube.com/watch?v=iLKSpfQWvMA
https://www.akshaykhot.com/how-rails-concerns-work-and-how-to-use-them/


Using concern we can add common code of controllers in concern module and include it in controller that will enhance readability


========================================================================================================================================================================
webpacker
========================================================================================================================================================================

before 5.X rails uses sprockets for managing the assets.

Rails 6 uses webpacker


========================================================================================================================================================================
active storage ( react-crud)
========================================================================================================================================================================

gem "trix-rails", require: "trix"
gem 'image_processing', '~> 1.2'
gem 'jquery-rails'
gem 'cloudinary'

bundle install

rails active_storage:install

apllication.js
//= require jquery
//= require trix

application.css
*= require trix


rails g scaffold books title:string
rails g scaffold images

config/cloudinary.yml

development:
  cloud_name: ""
  api_key: ""
  api_secret: ""
  secure: true

production:
  cloud_name: ""
  api_key: ""
  api_secret: ""
  secure: true



config/storage.yml
cloudinary:
  service: Cloudinary
  folder: rails_uploads

Comment to local in config/storage.yml


config/environments/development.rb
config.active_storage.service = :cloudinary

and Comment this line :
config.active_storage.service = :local


config/environments/application.rb
require 'cloudinary'

module Well
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 5.2

    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration can go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded after loading
    # the framework and any gems in your application.
    config.i18n.default_locale = :en
    config.assets.initialize_on_precompile = false
    config.exceptions_app = self.routes
    config.active_storage.service = :cloudinary
    Cloudinary.config_from_url("cloudinary://417697891113881:FNLTVGPyPgwUhvcwxIkC4zhQgl4@dvd6ckurb")

    Cloudinary.config do |config|
      config.secure = true
    end

  end
end


assets/javascripts/.coffee:

$(document).ready ->
  uploadAttachment = (attachment) ->
    csrfToken = $('meta[name="csrf-token"]').attr('content')
    file = attachment.file
    form = new FormData
    endpoint = '/images.json'
    form.append 'Content-Type', file.type
    form.append 'image[attachment]', file
    xhr = new XMLHttpRequest
    xhr.open 'POST', endpoint, true
    xhr.setRequestHeader 'X-CSRF-Token', Rails.csrfToken()
    xhr.upload.onprogress = (event) ->
      progress = event.loaded / event.total * 100
      attachment.setUploadProgress progress
    xhr.onload = ->
      if @status >= 200 and @status < 300
        data = JSON.parse(@responseText)
        return attachment.setAttributes(
          url: data.attachment_url
          href: data.attachment_url)
      return
    xhr.send form
  Trix.config.attachments.preview.caption =
    name: false
    size: false
  document.addEventListener 'trix-attachment-add', (event) ->
    attachment = event.attachment
    if attachment.file
      return uploadAttachment(attachment)
    return
  return


image.rb:
class Image < ApplicationRecord
  has_one_attached :attachment
end

book.rb:
class Book < ApplicationRecord
  has_one_attached :image
  has_many_attached :pictures
end


images_contoller.rb:
def image_params
  params.require(:image).permit(:attachment)
end

books_controller.rb:
def book_params
 params.require(:book).permit(:title, :image, pictures: [])
end

views/images/_image.json.builder:
json.attachment_url rails_blob_url(image.attachment)

book/show.html:
<p>
  <strong>Title:</strong>
  <%= sanitize @book.title %>
</p>

<%= link_to image_tag(@book.image,style: "width:150px; height: 150px;"),@book.image %>
<hr/>
<% @book.pictures.each do |picture| %>
  <%= link_to image_tag(picture,style: "width:150px; height: 150px;"),picture %>
<% end %>

book/_form.html:
 <div class="field">
    <%= form.label :title %>
    <%= form.trix_editor :title %>
  </div>

 <div class="field">
    <%= form.label :image %>
    <%= form.file_field :image %>
  </div>

  <div class="field">
    <%= form.label :pictures %>
    <%= form.file_field :pictures, multiple: true %>
  </div>



rails db:migrate

routes:
root 'books#index'

**************

check icon attached or not:

 object.icon.attached?

========================================================================================================================================================================
Cloudinary (react-crud)
========================================================================================================================================================================

1) add gem
2) add env variables for cloudinary
3) add cloudinary.rb file in config/initializers
4)


config/storage.yml
cloudinary:
  service: Cloudinary
  folder: rails_uploads

Comment to local in config/storage.yml


config/environments/development.rb
config.active_storage.service = :cloudinary

and Comment this line :
config.active_storage.service = :local


config/environments/application.rb
require 'cloudinary'

module ReactCrud
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 5.2

    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration can go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded after loading
    # the framework and any gems in your application.
    config.i18n.default_locale = :en
    config.assets.initialize_on_precompile = false
    config.exceptions_app = self.routes
    config.active_storage.service = :cloudinary
    Cloudinary.config_from_url("cloudinary://417697891113881:FNLTVGPyPgwUhvcwxIkC4zhQgl4@dvd6ckurb")

    Cloudinary.config do |config|
      config.secure = true
    end

  end
end


========================================================================================================================================================================
debugging
========================================================================================================================================================================




<%= debug(params) %>
<%= debug(@post) %>
<%= simple_format(@post.to_yaml) %>

<%= @post.inspect %>

**************************

gem 'web-console'

to get console, add console statement anywhere on page:
we write any query there and can access instance variables also:


<%= console %>

**************************

gem 'pry-rails'

********

gem "table_print"

tp Post.all

**************************

rails c --sandbox

now any change in database will be rollback

**************************

use byebug anywhere:

byebug

========================================================================================================================================================================
environment variables  (figaro)
========================================================================================================================================================================

figaro:
https://github.com/laserlemon/figaro

we use figaro gem to add environment variables:

1) gem 'figaro'
2) bundle exec figaro install

add variables in config/application.yml by this syntax:
key_name: "value"

and access like:
ENV["key_name"]


==================================================================================================================================
Credentials
==================================================================================================================================
Ruby on Rails #28 Action Mailer: Gmail SMTP - send emails in production for free
https://www.youtube.com/watch?v=eYhi_rbnOo8

1) EDITOR=vim rails credentials:edit
or EDITOR="code --wait" bin/rails credentials:edit


esc i   to insert

:wq    to save

2) add credentails in this file like:
google_smtp:
  email: --- ,
  password: ----

and access using
Rails.application.credentials.dig(:google_smtp, :email),



==================================================================================================================================
Email Verification devise
==================================================================================================================================


https://www.youtube.com/watch?v=GXsL2p0YoHg

https://github.com/heartcombo/devise/wiki/How-To:-Add-:confirmable-to-Users

***************************

1) add :confirmable in devise model
2) rails g migration add_confirmable_to_devise


class AddConfirmableToDevise < ActiveRecord::Migration[5.2]
   # Note: You can't use change, as User.update_all will fail in the down migration
  def up
    add_column :users, :confirmation_token, :string
    add_column :users, :confirmed_at, :datetime
    add_column :users, :confirmation_sent_at, :datetime
    add_column :users, :unconfirmed_email, :string # Only if using reconfirmable
    add_index :users, :coBootstrapnfirmation_token, unique: true
    # User.reset_column_information # Need for some types of updates, but not for update_all.
    # To avoid a short time window between running the migration and updating all existing
    # users as confirmed, do the following
    User.update_all confirmed_at: DateTime.now
    # All existing user accounts should be able to log in after this.
  end

  def down
    remove_index :users, :confirmation_token
    remove_columns :users, :confirmation_token, :confirmed_at, :confirmation_sent_at
    # remove_columns :users, :unconfirmed_email # Only if using reconfirmable
  end
end


3) add in development.rb

config.action_mailer.perform_deliveries = true
  config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
  config.action_mailer.delivery_method = :smtp
  config.action_mailer.smtp_settings = {
    address: 'smtp.gmail.com',
    port: 587,
    domain: 'example.com',
    user_name: ENV["email"],
    password: ENV["password"],
    authentication: 'plain',
    enable_starttls_auto: true
  }



******************


if something went wrong

set it to true

  config.action_mailer.raise_delivery_errors = true


******************

Ruby on Rails #28 Action Mailer: Gmail SMTP - send emails in production for free
https://www.youtube.com/watch?v=eYhi_rbnOo8

1) EDITOR=vim rails credentials:edit

esc i   to insert

:wq    to save

2) add credentails in this file like:
google_smtp:
  email: --- ,
  password: ----

and access using
Rails.application.credentials.dig(:google_smtp, :email),



==================================================================================================================================
Devise controllers
==================================================================================================================================
https://stackoverflow.com/questions/6234045/how-do-you-access-devise-controllers

rails generate devise:controllers users

devise_for :users,controllers: {
  registrations:'users/registrations'
}


name, age, gender, email, username, and profile picture
==================================================================================================================================
error pages
==================================================================================================================================


https://web-crunch.com/posts/custom-error-page-ruby-on-rails

rails g controller errors not_found internal_server_error


==================================================================================================================================
postgre sql
==================================================================================================================================


https://www.youtube.com/watch?v=v4yrpGy8NTs

Open the PostgreSQL interactive terminal as the "postgres" user
$ sudo -u postgres psql


rails new instagram-clone -d postgresql
add credentials in config/database.yml
rails db:create


********************
chnage databaser from sqlite to postgres:
********************

https://www.bogotobogo.com/RubyOnRails/RubyOnRails_Devise_Authentication_Sending_Confirmation_Email.php

1) add gem
gem 'pg', '>= 0.18', '< 2.0'

2) edit config/database.yml (we can just add in default)

default: &default
  adapter: postgresql
  encoding: unicode
  username: nouman
  password: noumanrehman042
  host: localhost
  port: 5432
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>


3) run
rails db:create
rails db:migrate
rails db:seed (if you have a seed file)

Now test your app, and you are now using Postgres!

postgres username: nouman
password: noumanrehman042

*************************

setup postgress user:

1) Open the PostgreSQL interactive terminal as the "postgres" user
$ sudo -u postgres psql

2) create the new user:
$ CREATE USER nouman WITH PASSWORD 'noumanrehman042';

3) Grant necessary privileges to the user. You can grant specific privileges to the user as needed.

For example, to grant the user the ability to create databases, you can use:
$ ALTER USER nouman CREATEDB;

To grant superuser privileges (be cautious with this), you can use:
$ ALTER USER nouman WITH SUPERUSER;

4) Exit the PostgreSQL interactive terminal by typing:

\q

*************************************
chnage databaser from postgres to sqlite
*************************************

1) create `db/development.sqlite3` file
(create test or production db files if needed)

2) add this gem and run bundle:
gem "sqlite3"

2) Paste below config in database.yml file:

# SQLite. Versions 3.8.0 and up are supported.
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem "sqlite3"
#
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  <<: *default
  database: db/test.sqlite3

production:
  <<: *default
  database: db/production.sqlite3

3) run below commands in terminal:

bundle install
rails db:create
rails db:migrate
rails db:seed

==================================================================================================================================
pundit
==================================================================================================================================


pundit
https://rubygems.org/gems/pundit/versions/1.1.0

https://github.com/varvet/pundit


1) add gem for all environments
gem 'pundit'
bundle

2)

rails g pundit:install
this will create policies folder in app

3) include it in your application controller:

class ApplicationController < ActionController::Base
  include Pundit::Authorization
  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized

  private

  def user_not_authorized
    flash[:alert] = "You are not authorized to perform this action."
    redirect_back(fallback_location: root_path)
  end
end


4)
rails g pundit:policy account  ( name of model in lowercase)
this will also initialze it in app policy


****************

user is the current user in pundit
record is the object we passed with authorize


***************

def pundit_user
  current_account
end

def destroy
  authorize @post  # we can access this passed object using record
  if @post.destroy
    flash[:notice] = "Post deleted!"
  else
    flash[:alert] = "Something went wrong ..."
  end
  redirect_to posts_path
end


def destroy?
  user == record.account  #   return true if we want to allow this action
end

***************

rails g pundit:policy post
rails g pundit:policy comment
rails g pundit:policy account
rails g pundit:policy story


==================================================================================================================================
rspec tests
==================================================================================================================================

https://github.com/rspec/rspec-rails

https://relishapp.com/rspec/rspec-rails/docs/

https://relishapp.com/rspec/rspec-rails/v/5-1/docs/controller-specs/controller-spec

https://github.com/simplecov-ruby/simplecov

rspec playlist
https://www.youtube.com/watch?v=Spogv4o8haM&list=PLS6F722u-R6KiuOupokyl8Xnqrot9ukc7&index=47


***************************
run test:
1) rspec
2) RUBYOPT="-W0" rspec

***************************

1) gem 'rspec-rails'

2) rails generate rspec:install

3) rails generate model article            -- way to create model

rails generate rspec:model article         -- way to create rspec for this model


4) rails g rspec:controller articles


***********************

add in .rspec:

--format documentation

*********************

rails stats

*********************
https://github.com/pry/pry-rails

gem 'pry-rails'

bundle
*********************
simple cov

1) add gem and bundle
2) add 2 lines in spec_helper

xdg-open coverage/index.html

***********************

https://github.com/thoughtbot/factory_bot/blob/master/GETTING_STARTED.md#configure-your-test-suite

gem 'factory_bot_rails'
bundle


add in rails helper
config.include FactoryBot::Syntax::Methods

article = FactoryBot.create(:article)

==================================================================================================================================
rubocop
==================================================================================================================================


gem 'rubocop', require: false
bundle
rubocop --auto-gen-config
rubocop -a


*************
vscode settings for rubocop:

"ruby.rubocop.executePath": "/usr/share/rvm/gems/ruby-2.7.0/wrappers/rubocop",
"ruby.rubocop.useBundler": true,
"ruby.rubocop.onSave": true,
"ruby.format": "rubocop",
"[ruby]": {
  "editor.defaultFormatter": "misogi.ruby-rubocop"
},

*************
setup rubocop:

1) add gems

gemfile:
group :development, :test do
  gem 'rubocop'
  gem 'rubocop-performance'
  gem 'rubocop-rails'
  gem 'rubocop-rspec'
end

2) create files:

.rubocop.yml:
require: rubocop-rspec
require: rubocop-rails

inherit_from: .rubocop_todo.yml


.rubocop_todo.yml:
AllCops:
  SuggestExtensions: false
  TargetRubyVersion: 2.7
  TargetRailsVersion: 5.2
  Exclude:
    - "db/schema.rb"
    - "node_modules/**/*"
    - "vendor/bundle/**/*"
    - "bin/**/*"

Layout/LineLength:
  Max: 120

Metrics/MethodLength:
  Max: 23

Metrics/BlockLength:
  Exclude:
    - config/**/*
    - spec/**/*

Lint/AmbiguousBlockAssociation:
  Exclude:
    - spec/**/*

Style/Documentation:
  Enabled: false

Metrics/AbcSize:
  Exclude:
    - "app/helpers/posts_helper.rb"

==================================================================================================================================
active_model_serializers
==================================================================================================================================


1) gem 'active_model_serializers', '~> 0.10.2'

2) rails g serializer post

***********************

docs:  https://github.com/rails-api/active_model_serializers/blob/0-10-stable/docs/general/getting_started.md




gem 'active_model_serializers', '~> 0.10.2'


rails g resource post title:string body:string

# frozen_string_literal: true

# PostSerializer
class PostSerializer < ActiveModel::Serializer
  belongs_to :user
  has_many :comments
  has_many :likes
  has_many :reports
  attributes :id, :title, :text, :created_at, :avatar_url, :comment_likes

  def avatar_url
    object.image.service_url if object.image.attached?
  end

  def comment_likes
    Like.group(:likeable_id).where(likeable_type: 'Comment').count
  end
end





========================================================================================================================================================================
end of project Notes
========================================================================================================================================================================
========================================================================================================================================================================
========================================================================================================================================================================
========================================================================================================================================================================



========================================================================================================================================================================
9_Best_Practices.txt
========================================================================================================================================================================

Caching With Instance Variable



class Project < ActiveRecord::Base
    belongs_to :creator, :class_name => “User”
    def company
        @company ||= creator.company
    end
end


******************

Use Local Variables in Place of Instance Variables in Partials

<%= render :partial => 'header' %>

Good Practice
<%= render :partial =>  'header', :locals => {:project => @project} %>

********************

Prevent SQL Injection:

Bad Practice
User.where(“name = #{params[:name]}“)

## Good Practice
User.where(“name = ?”, params[:name])
or
User.where(:name => params[:name])


********************

Avoid the n+1 Problem

Rails has a (in)famous query problem known as the n+1 query problem i.e eagerloading.

in controller:
@users = User.limit(50)

In the view:
<% @users.each do |user|%>
    <%= user.house.address %>
<% end %>

The above code will execute 51 queries, 1 to fetch all users and other 50 to fetch house of each user.
Active Record lets you specify in advance all the associations that are going to be loaded. This is possible by specifying the includes method of the Model.find call. With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.

## Good Practice
The retrieval should be made as follows

In the Controller
@users = User.includes(:house).limit(50)
In the view
<% @users.each do |user|%>
    <%= user.house.address %>
<% end %>

********************

Follow The Law of Demeter:

According to law of Demeter, a model should only talk to its immediate associated models. If you want to use associated attributes then you should use ‘delegate’.


## Bad Practice
class Project < ActiveRecord::Base
    belongs_to :creator
end

In the view:
<%= @project.creator.name %>
<%= @project.creator.company %>


## Good Practice
class Project > ActiveRecord::Base
   belongs_to :creator
   delegate :name, :company, :to => :creator, :prefix => true
end


In the view:
<%= @project.creator_name %>
<%= @project.creator_company %>


*************************

Declare Instance Variables Inside the Action

As a convention, instance variables should not be hidden in private methods but declared inside the action.


before_filter :get_project

def show
    @project = get_project
    @tasks = @project.tasks
end

private
def get_project
    Project.find(params[:id])
end


**************************

Use Lambda in Scopes

*************************

Use ? At the End of Method Name If It Is Returning Boolean Value

## Bad Practice
def exist
end

Good Practice
def exist?
end

*************************


Make Helper Methods for Views:

The MVC paradigm advocates keeping the views as clean as possible from any calculations. Still, sometimes this cannot be avoided, so for those instances do the processing with helpers.




<% case @filter %>
<% when 'inbox' %>
    <%= render 'inbox'%>
<% when 'sent' %>
    <%= render 'sent' %>
<% when 'draft' %>
    <%= render 'draft' %>
<% when 'trash'%>
    <%= render 'trash' %>
<% end %>


Goog Practice:

<%= render filter_templates(@filter) %>

def filter_templates(filter)
    case filter
    when 'inbox'
        render 'inbox'
    when 'sent'
        render 'sent'
    when 'draft'
        render 'draft'
    when 'trash'
        render  'trash'
    end
end



========================================================================================================================================================================
naming conventions
========================================================================================================================================================================

General Ruby conventions


Class names are CamelCase.

Methods and variables are snake_case.

Methods with a ? suffix will return a boolean.

Methods with a ! suffix mean one of two things: either the method operates destructively in some fashion, or it will raise and exception instead of failing (such as Rails models' #save! vs. #save).

*******************************


Model class names :
	singular
	use CamelCase
        plural database table name.


Rails will plularize your tablename
Model name will automatically get pluralize in database


Model naming convention

Model/Class	Table/Schema
Article	articles
LineItem	line_items
Deer		  deers
Mouse		  mice
Person		people


rails g model  LineItem name
will generate table with name line_items


Suppose you have Model name Book , it will store in sqlite as books and
in model it will be class name as  Book

This will create a Book model, mapped to a books table at the database

Book.all
Book.new
@book.save
@book.update
@book.destroy


*********************************


Controllers :
  use Plural name


rails g controller UiConfigurations

will create:
  create  app/controllers/ui_configurations_controller.rb
  invoke  erb
  create    app/views/ui_configurations
  invoke  rspec
  create    spec/requests/ui_configurations_spec.rb
  invoke  helper
  create    app/helpers/ui_configurations_helper.rb
  invoke    rspec
  create      spec/helpers/ui_configurations_helper_spec.rb
  invoke  assets
  invoke    css
  create      app/assets/stylesheets/ui_configurations.css




*********************************

rails g model UiConfiguration content_component:references ui_component:references rank:integer active:boolean


invoke  active_record
      create    db/migrate/20230201101909_create_ui_configurations.rb
      create    app/models/ui_configuration.rb
      invoke    rspec
      create      spec/models/ui_configuration_spec.rb
      invoke      factory_bot
      create        spec/factories/ui_configurations_factory.rb



*********************************


routes

Route names are snake_case , and usually match the controller. Most of the time routes
are plural and use the plural resources .


*******************************

rails g controller Comments

rails g model Comment

resources :comments


========================================================================================================================================================================
rails basic commands
========================================================================================================================================================================

 redirect_to action: 'read_cookie'



***********************

rails destroy :

rails destroy controller CookiesController


rails destroy model Person

*****************************

drop table in cli console:

Open Sqlite:

sqlite3 db/development.sqlite3


sqlite> drop table table_name;
sqlite> .quit


************************


$ rake routes -c articles    (  see all routes of article )

rails g  (  see all generators )

rails -T ( see all available rails commands)

rails -T db  ( filter by namespace db)



********************

Rails console:

rails c

reload!

clear irb screen with ctrl+l

********************

gem 'jquery-rails'

bundle install



Put this in your app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs







========================================================================================================================================================================
rails error solution
========================================================================================================================================================================



1) `initialize': No such file or directory - connect(2)
`spawn': No such file or directory - /home/dev/Rails/Day (Errno::ENOENT)


solution:  https://stackoverflow.com/questions/48703240/module-build-failed-error-spawn-bin-rails-enoent

run this command:
rails app:update:bin

******************************


https://stackoverflow.com/questions/19961821/why-bundle-install-is-installing-gems-in-vendor-bundle

To Install Gem in system wide avoiding path vendor/bundle, just run the following command in project directory

bundle install --system

******************************

Rails 4: check if a local variable exists and is true in a partial

https://stackoverflow.com/questions/23018339/rails-4-check-if-a-local-variable-exists-and-is-true-in-a-partial


******************************


Render and/or redirect were called multiple times in this action.
Please note that you may only call render OR redirect, and at most once per action.

Also note that neither redirect nor render terminate execution of the action,
so if you want to exit an action after redirecting, you need to do something like "redirect_to(...) and return".


******************************

remove warnings:

https://stackoverflow.com/questions/59491848/how-to-fix-railss-warning-messages-with-ruby-2-7-0

RUBYOPT='-W0'  rails s

or

export RUBYOPT='-W0'
rails s

******************************

kill
kill -9 $(lsof -i tcp:3000 -t)


********************************

error: cannot load such file -- /home/dev/.rvm/rubies/ruby-2.7.0/lib/ruby/gems/2.7.0/gems/bundler-2.1.2/exe/bundle (LoadError)

solution:
remove gem.lock file and
run bunlde install


========================================================================================================================================================================
rails installations: gems
========================================================================================================================================================================


gem install rails -v 5.2.0


I accidentally installed rails version 4.1.7 but I need rails version 4.1.6 . In order to fix this issue I uninstalled rails with this command:

gem uninstall rails
gem install rails -v 5.2
sudo gem uninstall railties

***********************
install ruby 2.7.0
***********************

rvm uninstall "ruby-2.7.2"
rvm install "ruby-2.7.0"

sudo rvm --default use 2.7.0



rvm list

=* ruby-2.7.0 [ x86_64 ]
   ruby-3.0.0 [ x86_64 ]

# => - current
# =* - current && default
#  * - default


https://rvm.io/rubies/default

***********************
Error ruby version:
How to fix "Your Ruby version is 2.3.0, but your Gemfile specified 2.2.5" while server starting

Fix:

You better install Ruby 2.2.5 for compatibility. The Ruby version in your local machine is different from the one declared in Gemfile.

If you're using rvm:

rvm install 2.2.5
rvm use 2.2.5

***********************

mrsool:

/bin/bash --login
rvm install "ruby-2.6.5"
sudo rvm --default use 2.6.5

************************

rvm install "ruby-2.7.7"
sudo rvm --default use 2.7.7


***********************

gem list

bundle -v
bundler -v
gem list | grep "bundle"
gem install --default bundler:2.3.19

gem install bundler:2.3.19


***********************

nvm = node version manager

nvm install 19.0.0

https://betterprogramming.pub/how-to-use-nvm-to-manage-node-js-19-and-npm-9-bc5656d52d5f

***********************

sudo apt install sqlitebrowser

**********************

Put this in your app/assets/javascripts/application.js

//= require jquery
//= require jquery_ujs
and install this gem file:

gem 'jquery-rails'
bundle install

************************

add favicon:

https://discoposse.com/2018/09/04/setting-your-favicon-in-ruby-on-rails-apps/


The code block is super easy to remember…except when I need to remember it, so here it is:

<%= favicon_link_tag asset_path('image-name.ico') %>

Here are the steps to set up your favicon in your Rails app:

Generate your icon
Copy the icon to the app/assets/images folder
Create the pointer in the HEADsection of your app/views/layouts/application.html.erb file as shown here:

========================================================================================================================================================================
gems -- multiple rails version
========================================================================================================================================================================

https://gorails.com/forum/running-multiple-rails-versions

Every Rails project has the version of Rails in the Gemfile that it will use separately from every other app. There's nothing you need to do to manage two different Rails versions.

The only thing you'll want to do is gem install rails to get the latest version and create your new project with rails new myapp. That will make sure the new project starts with Rails 5.1 (or whatever is the latest at the time).

You can also create apps with older versions of rails using rails _5.2.8.1_ new myapp

Rbenv and Rvm have pretty much nothing to do with this because they are for Ruby versions, not Rails. All of this is taken care of by Bundler.

When you switch apps to work on the correct versions will be automatically used, no changes required by you.



*********************************

https://relativkreativ.at/articles/how-to-manage-multiple-rails-versions


bundle exec rails -v

*******************************


see all gems:
gem list --local

*********************************

rails _5.2.8.1_ new myapp

5.2.8.1

*********************************


Put this in your app/assets/javascripts/application.js

//= require jquery
//= require jquery_ujs
and install this gem file:

gem 'jquery-rails'
bundle install

========================================================================================================================================================================
gems discovered:
========================================================================================================================================================================

carrierwave   for file uploads
fog           use fog instead of file with carrierwave

mini_magick   for resizing images

figaro        to use environment variables in development

toastr_rails   to show notices   https://www.youtube.com/watch?v=4XZPfujnRUI&list=PLN8D2dU8NedZ44iF8bvk5-SoVv21ipsPK&index=8

paperclip       for image uploading

dropzonejs-rails   for asynchronous multifile upload     https://github.com/ncuesta/dropzonejs-rails

for user friends:
https://github.com/has-friendship/has_friendship

Pundit        for Authorization

rolify        to add user roles

gem 'ransack'        for searching

devise_invitable   --  send invites to users ( It adds support to Devise for sending invitations by email (it requires to be authenticated) and accept the invitation setting the password.)

invisible_captcha   -- a time-sensitive hourglass form submission
https://github.com/markets/invisible_captcha Complete and flexible spam protection solution for Rails applications.
https://www.youtube.com/watch?v=4Z4yVSXDRyw&list=PLdTytUiloS15XyPr5HBwW5KzvsNioQYJV&index=15


activerecord-import -- fast and efficient way to insert multiple records into a database in a single SQL statement
                        Person.import( array of objects)



*******************

fontawesome
https://fontawesome.com/docs/web/use-with/ruby-on-rails
https://fontawesome.com/icons/

free icons:
https://fontawesome.com/search?m=free&o=r


1) add gem
gem "font-awesome-sass", "~> 6.2.0"

2) bundle install

3) add in application.scss
@import "font-awesome";

**********************

https://github.com/faker-ruby/faker#generators

Faker

1) bundle add faker

2) User.create( email:Faker::Internet.email)
3) Tag.create( name: Faker::Movie.title)

rails c

Faker::Internet.email
Faker::Movie.title

name= Faker::Name.name,
email= Faker::Internet.email
title= Faker::Lorem.sentence(word_count: 3)
body=Faker::Lorem::paragraph(sentence_count: 3)

Comment.create(body: Faker::Quote.famous_last_words)

Post.create(title: Faker::Music.band, image_url: Faker::Avatar.image)


*************************
Add bootstrap:

https://www.youtube.com/watch?v=dqjF3C9A-Yg&t=794s   10:00

gem 'bootstrap', '~> 4.0.0'

bundle install

assets:
application.js
//= require bootstrap-sprockets


application.css renamed to aplication.scss

@import "bootstrap";

**********************

schema information:

https://github.com/ctran/annotate_models

1) add gem and run bundle:
gem 'annotate'

2) run in terminal to annotate only models:
annotate --models

Ideally, run it after each migration.

**************************

For development:  ( see Projects/blog_app)

# Guard is a command line tool to easily handle events on file system modifications.
gem 'guard', '~> 2.14', '>= 2.14.1'

# reload the browser after changes to assets/helpers/tests
gem 'guard-livereload', '~> 2.5', '>= 2.5.2', require: false

# Make errors prettier
gem 'better_errors', '~> 2.4'


for guard-livereload:
guard init livereload

run Guard:
bundle exec guard

add this in development.rb
BetterErrors::Middleware.allow_ip! "0.0.0.0/0"


**********************
erb file formatter extension:

ERB Formatter/Beautify


*********************

bullet:

1) Add in development group:
gem 'bullet'

2) add in developmnt.rb file (before last end)

Rails.application.configure do

  //
  //
  //

  config.after_initialize do
    Bullet.enable        = true
    Bullet.alert         = false
    Bullet.bullet_logger = false
    Bullet.console       = false
    Bullet.rails_logger  = false
    Bullet.add_footer    = true
  end
end

*********************

easy auto complete with ransack gem

*************************


gem 'pry-rails'

gem 'query_count'


*******************************
rails-erd

https://github.com/voormedia/rails-erd
https://voormedia.github.io/rails-erd/install.html

sudo apt-get install graphviz

Add gem 'rails-erd', group: :development to your application's Gemfile

Run bundle exec erd

*******************************
jquery-ui-rails

( used in Day2 -> CoffeeScriptPractice)

The gem 'jquery-ui-rails' is used in Ruby on Rails applications to easily integrate and use jQuery UI components.
jQuery UI is a popular JavaScript library that provides a collection of user interface components and interactions,
 such as drag-and-drop, resizable elements, date pickers, and sliders.


gem 'jquery-ui-rails'

*********************************
city-state

1) gem "city-state", "~> 0.1.0"

2) bundle

3) test on rails console

Listing Countries:*******
$ CS.countries
$ CS.countries.count

Listing States:*******

Retrieve a list of states for a specified country:

CS.states(:US)

CS.states(:PK)
 => {:BA=>"Balochistan", :GB=>"Gilgit-Baltistan", :IS=>"Islamabad", :JK=>"Azad Kashmir", :KP=>"Khyber Pakhtunkhwa", :PB=>"Punjab", :SD=>"Sindh"}


Note: The gem is case-insensitive. You can use variations like :US, :us, :Us, "us", and "US".

Listing Cities:******

Retrieve a list of cities for a specified state and country:

CS.cities(:AK, :US)

CS.cities(:PB, :PK) # get cities of Punjab pakistan


You can also specify the country, though it's optional. The gem remembers the last country you used:

CS.states(:BR)

CS.cities(:TO)  # This will use Brazil (BR) as the country


Miscellaneous Notes:

The country is an optional argument. The gem always uses the last country that you used.


========================================================================================================================================================================
enums- devise user role
========================================================================================================================================================================


How to Use Enums in Rails
https://blog.saeloun.com/2022/01/05/how-to-use-enums-in-rails.html#:~:text=An%20enum%20is%20an%20attribute,time%20by%20providing%20dynamic%20methods.


1) rails g migration add_role_to_users
  add_column :users, :role, :integer, default: 0, null: false

  this will also add default role to existing users


2)   enum role: [:user, :moderator,:admin]

:user => 0
:moderator => 1
:admin => 2

3) Commands:


ALl scopes works same ( get all users where status is admin):
  a) User.admin
  b) User.where(role: :admin)
  c) User.where(role: 2)

Set role to moderator
  user = User.last
  user.moderator!
  or
  user.role = :moderator
  user.role = "moderator"

Chack if user is moderator:
  user.moderator?

see all roles( use plural name):
  User.roles

**************************
Array approach is not flexible at all.
The recommended way is to use a hash instead of an array for enums,
because if we change the order of the values, we will break the whole logic inside our Rails app.

enum role: { user: 0, moderator: 1, admin: 2 }

**************************


Sufix:

enum role: { user: 0, moderator: 1, admin: 2 }, suffix: true

now we will use:
user.admin_role?
user.moderator_role?
user.moderator_role!
User.admin_role

**************************

Instead, we can add prefix and suffix as per our requirement and call the methods accordingly.


class Post < ActiveRecord::Base
  enum :status, { draft: 0, published: 1, archived: 2, trashed: 3 }, prefix: true
  enum :category, { free: 0, premium: 1 }, suffix: true
end

Post.free_category

post.status_published?

post.premium_category!

========================================================================================================================================================================
lines used
========================================================================================================================================================================



https://stackoverflow.com/questions/5679983/rspec-testing-ajax-response-should-render-a-partial

def create
  @project = Project.new...
  respond_to do |format|
    if @project.save
      format.js { render :partial => "projects/form" }
    end
  end
end


========================================================================================================================================================================
Caching in Rails
========================================================================================================================================================================


Caching in Rails is a technique used to store and retrieve frequently accessed data or computed results to improve the performance and responsiveness of your application.
Rails provides various mechanisms for caching at different levels, including fragment caching, page caching, action caching, and low-level caching.

Fragment Caching:
Fragment caching allows you to cache specific parts (fragments) of a view or a template. You can wrap the code or content that you want to cache within a cache block using the cache helper method. For example:
The cache method takes a unique cache key as its argument and a block where the content to be cached is rendered.
The cache key is essential to identify and retrieve the cached content. It should be unique and change whenever the content inside the cache block changes.

Copy code
<% cache('my_cached_fragment') do %>
  <!-- Code to cache -->
<% end %>

******************

Page Caching:
Page caching is the simplest form of caching, where the entire rendered page is stored as a static HTML file and served directly by the web server without invoking the Rails application. To enable page caching, you can use the caches_page method in your controller. For example:


class UsersController < ApplicationController
  caches_page :index, :show
  # ...
end

If you want to update the index page immediately after adding a new post without waiting for the cache to expire, you can manually invalidate the cache. This can be done using the expire_page method in your controller.

******************

Action Caching:
Action caching allows you to cache the output of an entire action. Unlike page caching, action caching doesn't create a static HTML file; instead, it caches the rendered output in memory or a store like Redis or Memcached. You can enable action caching by using the caches_action method in your controller. For example:

class ProductsController < ApplicationController
  caches_action :index, :show
  # ...
end

******************

Low-level Caching:
Low-level caching provides a more granular control over caching by allowing you to directly interact with the Rails cache store.

Rails.cache: read, write, and fetch

The fetch method is a convenient way to interact with the cache, combining the functionality of read and write.
You can use the Rails.cache.fetch method to fetch data from the cache or store data in the cache. For example:

Example:

cached_data = Rails.cache.fetch(cache_key, expires_in: 1.hour) do
  # Code to generate or fetch the data to be cached
  expensive_database_query
end

In this example, if the data with cache_key is not in the cache or has expired, the expensive_database_query will be executed, and the result will be stored in the cache with the specified expiration time. If the data is already present and valid, the expensive database query will be skipped, and the cached data will be returned directly.

******************

You can also specify additional options such as expiration time, dependencies, and cache keys using the expires_in, race_condition_ttl, and version options, respectively.

Additionally, Rails provides configuration options in config/environments/*.rb files to set the cache store, cache keys prefix, and other cache-related settings.

It's important to note that caching should be used judiciously and selectively for parts of your application that benefit the most from caching. Be cautious with caching dynamic content or content that needs to be updated frequently to avoid serving stale data.


========================================================================================================================================================================
ActiveRecord::Store
========================================================================================================================================================================

https://api.rubyonrails.org/classes/ActiveRecord/Store.html

In Ruby on Rails, the store method is actually a built-in feature provided by ActiveRecord.
It allows you to serialize and store structured data in a single database column without the need for an additional gem.


*********************************

# app/models/student.rb
class Student < ApplicationRecord
  store :details, coder: HashEval, accessors: %i[address age grade contact_number]
end

With this code, you don't need to define separate accessor methods explicitly.
The accessors option provided in the store method will automatically generate accessor methods for each key in the details hash.

****

You can now create a new Student and set values for the details attribute using the accessor methods:

ruby
Copy code
student = Student.new
student.address = '123 Main Street'
student.age = 16
student.grade = '10th'
student.contact_number = '555-1234'
student.save

Similarly, you can retrieve the values of specific keys in the details hash using the accessor methods:

student = Student.find(1)
address = student.address
age = student.age
grade = student.grade
contact_number = student.contact_number
By using the store method with the provided syntax, the details attribute is serialized as a hash using the HashEval coder. The accessors specified in the accessors option allow you to conveniently set and retrieve the values of specific keys in the details hash without explicitly defining separate accessor methods.

**********************************

class User < ApplicationRecord
  store :settings, accessors: [:color, :homepage], coder: JSON
  store :parent, accessors: [:name], coder: JSON, prefix: true
  store :spouse, accessors: [:name], coder: JSON, prefix: :partner
  store :settings, accessors: [:two_factor_auth], suffix: true
  store :settings, accessors: [:login_retry], suffix: :config
end

u = User.new(color: 'black', homepage: '37signals.com', parent_name: 'Mary', partner_name: 'Lily')
u.color                          # Accessor stored attribute
u.parent_name                    # Accessor stored attribute with prefix
u.partner_name                   # Accessor stored attribute with custom prefix
u.two_factor_auth_settings       # Accessor stored attribute with suffix
u.login_retry_config             # Accessor stored attribute with custom suffix
u.settings[:country] = 'Denmark' # Any attribute, even if not specified with an accessor

# There is no difference between strings and symbols for accessing custom attributes
u.settings[:country]  # => 'Denmark'
u.settings['country'] # => 'Denmark'

# Dirty tracking
u.color = 'green'
u.color_changed? # => true
u.color_was     # => 'black'
u.color_change  # => ['black', 'green']

# Add additional accessors to an existing store through store_accessor
class SuperUser < User
  store_accessor :settings, :privileges, :servants
  store_accessor :parent, :birthday, prefix: true
  store_accessor :settings, :secret_question, suffix: :config
end
By using ApplicationRecord as the base class for your models, you maintain compatibility with the conventions and features provided by Rails, including the built-in support for serialized attributes using the store method.

*****
User.stored_attributes[:settings] # => [:color, :homepage, :two_factor_auth, :login_retry]


========================================================================================================================================================================
A Comprehensive Comparison: Rails 6 vs Rails 7
========================================================================================================================================================================

Rails 7 brings exciting improvements to the table. Let’s dive in and discover what’s new!


1)Performance Enhancements:

2) Webpacker as Default JavaScript Compiler:

In Rails 6, Webpacker was introduced as an optional JavaScript compiler.

However, Rails 7 takes it a step further by making Webpacker the default JavaScript compiler, replacing the previously used Sprockets.

This change provides a more modern and flexible approach to managing JavaScript assets, allowing for a seamless integration of JavaScript frameworks like React or Vue.js.

3)  Encrypted Credentials by Default:

4)  Improved Error Handling:

5) Rich Text Editing:

Rails 7 introduces a new Action Text editor called Trix, which provides a rich text editing experience.
With Trix, users can format text, add images, embed videos, and more.
This feature simplifies the process of building content-rich applications, such as blogs, forums, or CMS platforms.
It eliminates the need for third-party plugins or integrations, making it easier to create and manage dynamic content within your Rails application.


========================================================================================================================================================================
Rails7

Topics:
Hotwire basics
stimulus-js

========================================================================================================================================================================

Hotwire basics:

Hotwire is a web development framework and set of tools designed to make building modern web applications faster and more efficient.
It is often associated with Ruby on Rails, a popular web application framework, as it was created by the same team.

Hotwire includes several components:

1. **Turbo:**
Turbo  speeds up the application by taking sections of your application and just re-redering just one section instead of doing a full page refresh.
With turbo you can also broadcast updates so that anyone who is subscribed to a particular channel will also receive those updates.
Turbo is a set of JavaScript libraries that work with your existing server-rendered HTML.
It allows you to enhance the user experience by sending HTML updates from the server, without needing to build a single-page application (SPA).
This can make your web applications more interactive without the complexity of full SPAs.

2. **Stimulus:**
Stimulus is a JavaScript framework for adding interactivity to your HTML using a simple and conventional approach.
It helps you create interactive elements on your web pages without the need for a complex JavaScript framework.

3. **Strada:**
Strada is a server-side component of Hotwire. It helps manage the communication between your client and server, making it possible to send HTML updates efficiently.

Hotwire aims to simplify the development of web applications by combining server-rendered HTML with modern JavaScript techniques, providing a balance between rich user experiences and development simplicity. It's particularly valuable for developers who prefer traditional server-side rendering but still want to add real-time or interactive features to their applications.


*************************************************
stimulus-js:
*************************************************

How it works:

Example 1:
(/home/dev/Rails-Training/Rails7/developers-community project)

1) generate stimulus controller:

$ rails g stimulus user_name

create app/javascript/controllers/user_name_controller.js file

2) in html.erb file to connect:

<div class="user-info" data-controller="user-name">
  <h5 data-user-name-target='name' data-action="click->user-name#getUserName"><%= user.name %></h5>
</div>

It will generate:

<div class="user-info" data-controller="user-name">
  <h5 data-user-name-target="name" data-action="click->user-name#getUserName">Syed Nouman</h5>
</div>

3) in stimulus controller:

import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="user-name"
export default class extends Controller {
  static targets = ['name']

  connect() {
    console.log('I am connected!!!');
  }

  getUserName = () => {
    const element = this.nameTarget
    const name = element.textContent
    alert(`You clicked on, ${name}`)
  }
}


Example 2:
(/home/dev/Rails-Training/Rails7/blog_application)

1) create controller (comments_controller.js) file in javascript

import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  initialize() {} // only run once
  connect() {}   // run each time we refresh
}


2) add data field in the element:

<%= link_to "Edit", nil, remote: true, class:"btn btn-warning",
      data: {
        controller: "comments",
        action: "comments#toggleForm",
        comments_form_param: "edit-form-#{comment.id}",
        comments_body_param: "comment-body-#{comment.id}",
        comments_edit_param: "edit-button-#{comment.id}"
      },
      id: "edit-button-#{comment.id}" %>

This will generate:

<a class="btn btn-warning"
  data-controller="comments"
  data-action="comments#toggleForm"
  data-comments-form-param="edit-form-52"
  data-comments-body-param="comment-body-52"
  data-comments-edit-param="edit-button-52"
  id="edit-button-52"
  data-remote="true" href="/posts/title-7">

  Edit
</a>

3) add action in controller:

import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  initialize() {} // only run once
  connect() {}   // run each time we refresh

  toggleForm(event) {
    console.log("I clicked the edit button.");
    event.preventDefault();
    event.stopPropagation();
    const formID = event.params["form"];
    const commentBodyID = event.params["body"];
    const editButtonID = event.params["edit"];

    const form = document.getElementById(formID);
    const commentBody = document.getElementById(commentBodyID);
    const editButton = document.getElementById(editButtonID);

    form.classList.toggle("d-none");
    form.classList.toggle("mt-5");
    commentBody.classList.toggle("d-none");
    this.toggleEditButton(editButton);
  }
}

*************************************************
actions in stimulus:
*************************************************

Stimulus provides a variety of actions that you can use in your Rails application to respond to user interactions and events.

Some of the common actions you can use include:

1. `click`:
   - Responds to a click event on an element.

2. `input`:
   - Responds to input events, typically used for form fields like text inputs and textareas.

   example:
      <%= form.search_field :title_search, data: { action: "input->debounce#search" } %>


3. `submit`:
   - Responds to a form submission event. Useful for form validation or custom form handling.

4. `change`:
   - Responds to a change event, often used with form elements like select boxes and radio buttons.

5. `dblclick`:
   - Responds to a double-click event on an element.

6. `mouseover` and `mouseout`:
   - Respond to mouseover and mouseout events, commonly used for implementing tooltips and hover effects.

7. `focus` and `blur`:
   - Respond to focus and blur events on form elements. Useful for input validation and styling.

8. `keydown`, `keyup`, and `keypress`:
   - Respond to keyboard-related events, such as key presses and releases.

9. `submit`:
   - Responds to a form submission event. Useful for custom form handling or validation.

10. `load`:
    - Respond to the page load event, often used for initializing JavaScript behavior when a page loads.

11. `resize`:
    - Respond to window resize events. Useful for responsive design and layout adjustments.

12. Custom events:
    - You can define custom events specific to your application's needs. For example, you might define a custom event like "refresh" and trigger it when you want to refresh a part of your application.

You can use these actions in combination with Stimulus controllers to create interactive and dynamic behavior in your Rails application. Each action corresponds to a specific DOM event, allowing you to trigger JavaScript actions when those events occur.


Default event for a particular element:

- For links (<a> elements) and buttons (<button> elements), the default action is usually a "click" event.
    These elements are primarily used for user interactions.

- For form fields like text inputs, textareas, and select boxes, the default event is typically "input" (i.e., when the user types or selects something in the field).
  However, for form submission buttons, it's usually the "click" event.

**********************************************
stumulus static attributes
1) target
2) values
3) classes
**********************************************

Here are simple examples for each of the static attributes in a Stimulus controller along with their use in an ERB file:

(See Examples ->  /Rails-Training/Rails7/Hotwire-SupeRails/66-stimulusjs-dropdown)

1. **Static Targets**:

   Suppose you're building a "To-Do List" application. You can use `static targets` to interact with the list items, the input field, and the add button.

   In the Stimulus controller:

   ```javascript
   // todo_controller.js
   import { Controller } from "stimulus"

   export default class extends Controller {
     static targets = ["item", "input", "addButton"]

     add() {
       // Add a new to-do item to the list
       const newItemText = this.inputTarget.value
       const newItem = document.createElement("li")
       newItem.textContent = newItemText
       this.itemTarget.appendChild(newItem)
       this.inputTarget.value = ""
     }
   }
   ```

   In the ERB file:

   ```html
   <!-- app/views/todos/index.html.erb -->
   <div data-controller="todo">
     <ul data-todo-target="item">
       <!-- List items will be dynamically added here -->
     </ul>
     <input type="text" data-todo-target="input">
     <button data-action="click->todo#add" data-todo-target="addButton">Add</button>
   </div>
   ```

   In this example, `data-todo-target` is used to specify the elements that the `todo` controller should interact with.

2. **Static Values**:

   Let's continue with the "To-Do List" example. You can use `static values` to track the count of to-do items.

   In the Stimulus controller:

   ```javascript
   // todo_controller.js
   import { Controller } from "stimulus"

   export default class extends Controller {
     static values = { itemCount: Number }

     connect() {
       this.itemCountValue = this.itemTargets.length
     }

     add() {
       // ... (same as previous example)
       this.itemCountValue++
     }
   }
   ```

   In the ERB file, you don't need to modify the HTML, but now you can access the `itemCount` value in your controller.

3. **Static Classes**:

   Suppose you want to highlight completed to-do items with a special style. You can use `static classes` to toggle a CSS class on these items.

   In the Stimulus controller:

   ```javascript
   // todo_controller.js
   import { Controller } from "stimulus"

   export default class extends Controller {
     static targets = ["item"]
     static classes = ["completed"]

     toggleCompleted(event) {
       const item = event.currentTarget
       item.classList.toggle(this.completedClass)
     }
   }
   ```

   In the ERB file:

   ```html
   <!-- app/views/todos/index.html.erb -->
   <ul>
     <li data-action="click->todo#toggleCompleted" data-todo-class="completed">Task 1</li>
     <li data-action="click->todo#toggleCompleted" data-todo-class="completed">Task 2</li>
     <!-- Add more items as needed -->
   </ul>
   ```

   In this example, `data-todo-class` specifies the CSS class that should be toggled when the user clicks on an item.

These examples illustrate how to use `static targets`, `static values`, and `static classes` in a practical context within an ERB file. You can adapt these concepts to your specific use cases and application requirements.

*****************************************************************
Turbo: The speed of a single-page web application without having to write any JavaScript.
https://turbo.hotwired.dev/
*****************************************************************
Turbo is a key component of Hotwire(set of technologies for building modern web applications).
It consists of several subcomponents that work together to provide real-time updates and interactive features in web applications. Here are the main components of Turbo, explained briefly:


1. **Turbo Frames**:
  - *Purpose*: Turbo Frames are used to isolate and update specific parts of a web page without a full page reload.
              They are ideal for situations where you want to replace or update a specific section of a page, such as a form or a list of items.
  - *Usage*: Turbo Frames are used to enclose a section of content that can be updated dynamically,
              like a chat message list or a product listing.
              When a Turbo Frame is updated, only the content within that frame is replaced, leaving the rest of the page intact.

2. **Turbo Streams**:
   - **Purpose**: Turbo Streams are used to push real-time updates to a client without the need for client-side JavaScript.
        They are excellent for sending updates to multiple clients when something changes on the server.
   - **Usage**: Turbo Streams work by broadcasting changes to the client. These changes can be in the form of creating, updating, or deleting records. The client interprets these instructions and updates the view accordingly.
   - **Example**: Turbo Streams can be used to instantly show new comments on a blog post for all connected users or to update the view when an item is added to a shopping cart in real-time.

2. **Turbo Streams**:
   - *Purpose*: Turbo Streams enable real-time updates by sending changes (creation, modification, deletion) to the client.
   - *Usage*: You can use Turbo Streams to push updates to clients when something changes on the server, such as new comments or items added to a shopping cart.


3. **Turbo Drive**:
      Turbo Drive is the part of Turbo that enhances page-level navigation.
      It watches for link clicks and form submissions, performs them in the background, and updates the page without doing a full reload.
      It’s the evolution of a library previously known as Turbolinks.

   - *Purpose*: Turbo Drive provides seamless navigation by intercepting link clicks and form submissions, loading the content via AJAX, and preserving browser history.
   - *Usage*: It's used to create fast and fluid navigation in a web application, where the whole page doesn't need to be reloaded for every interaction.

4. **Turbo Native**:
   - *Purpose*: Turbo Native is used for building hybrid mobile applications. It allows you to embed web views and use Turbo in a mobile app.
   - *Usage*: You can use Turbo Native to develop mobile apps that combine native functionality with web-based views.


Notes:
Turbo stream doesn’t respond to GET request, it only responds to POST request

========================================================================================================================================================================
Procfile (specifies the commands needed to run application)
========================================================================================================================================================================


1. **Procfile**:
A `Procfile` is a simple text file, usually named `Procfile` (with no file extension), that specifies the commands needed to run various components or processes of your application.
Each line in the `Procfile` corresponds to a process or service that your application relies on.

2. **Processes**:
Each line in the `Procfile` defines a process that can be started and managed.
These processes can include web servers, background workers, databases, and more.
For example, a typical `Procfile` for a web application might include lines for starting a web server, a background worker, and a database server.

PaaS (Platform-as-a-Service) providers like Heroku use Procfiles to understand how to run and manage your application.

In summary, a Procfile-based application is one that uses a `Procfile` to define and manage its processes,
making it easier to deploy, scale, and manage your application on Platform-as-a-Service providers and ensuring that all the necessary components of your application run as expected.

In a Ruby on Rails application, a `Procfile.dev` is not a standard file, but it can be used to define development processes using tools like Foreman or Heroku's `heroku local`.
It's a handy way to manage multiple development processes in a single file.

To create a `Procfile.dev` for your Rails app, follow these steps:

1. Open your Rails application directory in your code editor or terminal.

2. Create a new file named `Procfile.dev` in the root directory of your Rails application if it doesn't already exist.

3. In this file, define the processes or services you want to run in your development environment.
Each line should specify a process name and the command to run it. Here's an example of what a `Procfile.dev` might look like:

```bash
web: bundle exec rails server
worker: bundle exec sidekiq
webpack: ./bin/webpack-dev-server
```

In this example, we have defined three processes:

- `web` for running the Rails web server.
- `worker` for running Sidekiq (a background job processing tool).
- `webpack` for running the webpack-dev-server for JavaScript asset compilation.

You can add or modify processes as needed for your specific development environment.

4. Save the `Procfile.dev` file.

5. Install Foreman if you haven't already. You can install it using the following command:

```bash
gem install foreman
```

6. To start all the processes defined in the `Procfile.dev`, run the following command:

```bash
foreman start -f Procfile.dev
```

This command will start all the processes you've defined in your `Procfile.dev`. Make sure your development environment is properly set up and all necessary gems and dependencies are installed.

Using `Procfile.dev` with Heroku:
If you plan to deploy your Rails app to Heroku, you can also use the `Procfile.dev` with the Heroku local development tool. Heroku will recognize and use this file for your local development environment.

Remember that the specific processes and commands in your `Procfile.dev` may vary depending on your application's needs. It's a useful way to consolidate your development environment's processes and make it easier to manage multiple services during development.

**********************

Another example of rails procfile:

web: bin/rails server -p 3000
css: bin/rails tailwindcss:watch


**********************

Example Procfile for node:

web: node server.js
worker: node worker.js

In this example, there are two processes defined: a web process running a Node.js server and a worker process running some background tasks.

========================================================================================================================================================================

========================================================================================================================================================================







========================================================================================================================================================================

========================================================================================================================================================================







========================================================================================================================================================================

========================================================================================================================================================================



